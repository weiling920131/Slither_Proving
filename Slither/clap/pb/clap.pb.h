// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: clap.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_clap_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_clap_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_clap_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_clap_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_clap_2eproto;
namespace clap {
namespace pb {
class CPU;
class CPUDefaultTypeInternal;
extern CPUDefaultTypeInternal _CPU_default_instance_;
class GPU;
class GPUDefaultTypeInternal;
extern GPUDefaultTypeInternal _GPU_default_instance_;
class Hardware;
class HardwareDefaultTypeInternal;
extern HardwareDefaultTypeInternal _Hardware_default_instance_;
class Heartbeat;
class HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
class Model;
class ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class ModelInfo;
class ModelInfoDefaultTypeInternal;
extern ModelInfoDefaultTypeInternal _ModelInfo_default_instance_;
class Node;
class NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Packet;
class PacketDefaultTypeInternal;
extern PacketDefaultTypeInternal _Packet_default_instance_;
class Trajectories;
class TrajectoriesDefaultTypeInternal;
extern TrajectoriesDefaultTypeInternal _Trajectories_default_instance_;
class Trajectory;
class TrajectoryDefaultTypeInternal;
extern TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
class Trajectory_Statistics;
class Trajectory_StatisticsDefaultTypeInternal;
extern Trajectory_StatisticsDefaultTypeInternal _Trajectory_Statistics_default_instance_;
class WorkerState;
class WorkerStateDefaultTypeInternal;
extern WorkerStateDefaultTypeInternal _WorkerState_default_instance_;
class WorkerState_Evaluation;
class WorkerState_EvaluationDefaultTypeInternal;
extern WorkerState_EvaluationDefaultTypeInternal _WorkerState_Evaluation_default_instance_;
class WorkerState_Transition;
class WorkerState_TransitionDefaultTypeInternal;
extern WorkerState_TransitionDefaultTypeInternal _WorkerState_Transition_default_instance_;
class WorkerState_TreeOption;
class WorkerState_TreeOptionDefaultTypeInternal;
extern WorkerState_TreeOptionDefaultTypeInternal _WorkerState_TreeOption_default_instance_;
}  // namespace pb
}  // namespace clap
PROTOBUF_NAMESPACE_OPEN
template<> ::clap::pb::CPU* Arena::CreateMaybeMessage<::clap::pb::CPU>(Arena*);
template<> ::clap::pb::GPU* Arena::CreateMaybeMessage<::clap::pb::GPU>(Arena*);
template<> ::clap::pb::Hardware* Arena::CreateMaybeMessage<::clap::pb::Hardware>(Arena*);
template<> ::clap::pb::Heartbeat* Arena::CreateMaybeMessage<::clap::pb::Heartbeat>(Arena*);
template<> ::clap::pb::Model* Arena::CreateMaybeMessage<::clap::pb::Model>(Arena*);
template<> ::clap::pb::ModelInfo* Arena::CreateMaybeMessage<::clap::pb::ModelInfo>(Arena*);
template<> ::clap::pb::Node* Arena::CreateMaybeMessage<::clap::pb::Node>(Arena*);
template<> ::clap::pb::Packet* Arena::CreateMaybeMessage<::clap::pb::Packet>(Arena*);
template<> ::clap::pb::Trajectories* Arena::CreateMaybeMessage<::clap::pb::Trajectories>(Arena*);
template<> ::clap::pb::Trajectory* Arena::CreateMaybeMessage<::clap::pb::Trajectory>(Arena*);
template<> ::clap::pb::Trajectory_Statistics* Arena::CreateMaybeMessage<::clap::pb::Trajectory_Statistics>(Arena*);
template<> ::clap::pb::WorkerState* Arena::CreateMaybeMessage<::clap::pb::WorkerState>(Arena*);
template<> ::clap::pb::WorkerState_Evaluation* Arena::CreateMaybeMessage<::clap::pb::WorkerState_Evaluation>(Arena*);
template<> ::clap::pb::WorkerState_Transition* Arena::CreateMaybeMessage<::clap::pb::WorkerState_Transition>(Arena*);
template<> ::clap::pb::WorkerState_TreeOption* Arena::CreateMaybeMessage<::clap::pb::WorkerState_TreeOption>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace clap {
namespace pb {

// ===================================================================

class CPU PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clap.pb.CPU) */ {
 public:
  inline CPU() : CPU(nullptr) {}
  virtual ~CPU();

  CPU(const CPU& from);
  CPU(CPU&& from) noexcept
    : CPU() {
    *this = ::std::move(from);
  }

  inline CPU& operator=(const CPU& from) {
    CopyFrom(from);
    return *this;
  }
  inline CPU& operator=(CPU&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CPU& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CPU* internal_default_instance() {
    return reinterpret_cast<const CPU*>(
               &_CPU_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CPU& a, CPU& b) {
    a.Swap(&b);
  }
  inline void Swap(CPU* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CPU* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CPU* New() const final {
    return CreateMaybeMessage<CPU>(nullptr);
  }

  CPU* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CPU>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CPU& from);
  void MergeFrom(const CPU& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CPU* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clap.pb.CPU";
  }
  protected:
  explicit CPU(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_clap_2eproto);
    return ::descriptor_table_clap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCoresFieldNumber = 2,
    kThreadsFieldNumber = 3,
    kClockFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 cores = 2;
  void clear_cores();
  ::PROTOBUF_NAMESPACE_ID::int32 cores() const;
  void set_cores(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cores() const;
  void _internal_set_cores(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 threads = 3;
  void clear_threads();
  ::PROTOBUF_NAMESPACE_ID::int32 threads() const;
  void set_threads(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_threads() const;
  void _internal_set_threads(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float clock = 4;
  void clear_clock();
  float clock() const;
  void set_clock(float value);
  private:
  float _internal_clock() const;
  void _internal_set_clock(float value);
  public:

  // @@protoc_insertion_point(class_scope:clap.pb.CPU)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 cores_;
  ::PROTOBUF_NAMESPACE_ID::int32 threads_;
  float clock_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_clap_2eproto;
};
// -------------------------------------------------------------------

class GPU PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clap.pb.GPU) */ {
 public:
  inline GPU() : GPU(nullptr) {}
  virtual ~GPU();

  GPU(const GPU& from);
  GPU(GPU&& from) noexcept
    : GPU() {
    *this = ::std::move(from);
  }

  inline GPU& operator=(const GPU& from) {
    CopyFrom(from);
    return *this;
  }
  inline GPU& operator=(GPU&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GPU& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GPU* internal_default_instance() {
    return reinterpret_cast<const GPU*>(
               &_GPU_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GPU& a, GPU& b) {
    a.Swap(&b);
  }
  inline void Swap(GPU* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GPU* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GPU* New() const final {
    return CreateMaybeMessage<GPU>(nullptr);
  }

  GPU* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GPU>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GPU& from);
  void MergeFrom(const GPU& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GPU* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clap.pb.GPU";
  }
  protected:
  explicit GPU(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_clap_2eproto);
    return ::descriptor_table_clap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kMemoryFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 memory = 2;
  void clear_memory();
  ::PROTOBUF_NAMESPACE_ID::int64 memory() const;
  void set_memory(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_memory() const;
  void _internal_set_memory(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:clap.pb.GPU)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 memory_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_clap_2eproto;
};
// -------------------------------------------------------------------

class Hardware PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clap.pb.Hardware) */ {
 public:
  inline Hardware() : Hardware(nullptr) {}
  virtual ~Hardware();

  Hardware(const Hardware& from);
  Hardware(Hardware&& from) noexcept
    : Hardware() {
    *this = ::std::move(from);
  }

  inline Hardware& operator=(const Hardware& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hardware& operator=(Hardware&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Hardware& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Hardware* internal_default_instance() {
    return reinterpret_cast<const Hardware*>(
               &_Hardware_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Hardware& a, Hardware& b) {
    a.Swap(&b);
  }
  inline void Swap(Hardware* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hardware* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Hardware* New() const final {
    return CreateMaybeMessage<Hardware>(nullptr);
  }

  Hardware* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Hardware>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Hardware& from);
  void MergeFrom(const Hardware& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hardware* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clap.pb.Hardware";
  }
  protected:
  explicit Hardware(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_clap_2eproto);
    return ::descriptor_table_clap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCpusFieldNumber = 1,
    kGpusFieldNumber = 2,
  };
  // repeated .clap.pb.CPU cpus = 1;
  int cpus_size() const;
  private:
  int _internal_cpus_size() const;
  public:
  void clear_cpus();
  ::clap::pb::CPU* mutable_cpus(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::CPU >*
      mutable_cpus();
  private:
  const ::clap::pb::CPU& _internal_cpus(int index) const;
  ::clap::pb::CPU* _internal_add_cpus();
  public:
  const ::clap::pb::CPU& cpus(int index) const;
  ::clap::pb::CPU* add_cpus();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::CPU >&
      cpus() const;

  // repeated .clap.pb.GPU gpus = 2;
  int gpus_size() const;
  private:
  int _internal_gpus_size() const;
  public:
  void clear_gpus();
  ::clap::pb::GPU* mutable_gpus(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::GPU >*
      mutable_gpus();
  private:
  const ::clap::pb::GPU& _internal_gpus(int index) const;
  ::clap::pb::GPU* _internal_add_gpus();
  public:
  const ::clap::pb::GPU& gpus(int index) const;
  ::clap::pb::GPU* add_gpus();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::GPU >&
      gpus() const;

  // @@protoc_insertion_point(class_scope:clap.pb.Hardware)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::CPU > cpus_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::GPU > gpus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_clap_2eproto;
};
// -------------------------------------------------------------------

class Node PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clap.pb.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  virtual ~Node();

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Node& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Node* New() const final {
    return CreateMaybeMessage<Node>(nullptr);
  }

  Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clap.pb.Node";
  }
  protected:
  explicit Node(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_clap_2eproto);
    return ::descriptor_table_clap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentityFieldNumber = 1,
    kHostnameFieldNumber = 2,
    kHardwareFieldNumber = 3,
  };
  // string identity = 1;
  void clear_identity();
  const std::string& identity() const;
  void set_identity(const std::string& value);
  void set_identity(std::string&& value);
  void set_identity(const char* value);
  void set_identity(const char* value, size_t size);
  std::string* mutable_identity();
  std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // string hostname = 2;
  void clear_hostname();
  const std::string& hostname() const;
  void set_hostname(const std::string& value);
  void set_hostname(std::string&& value);
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  std::string* mutable_hostname();
  std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // .clap.pb.Hardware hardware = 3;
  bool has_hardware() const;
  private:
  bool _internal_has_hardware() const;
  public:
  void clear_hardware();
  const ::clap::pb::Hardware& hardware() const;
  ::clap::pb::Hardware* release_hardware();
  ::clap::pb::Hardware* mutable_hardware();
  void set_allocated_hardware(::clap::pb::Hardware* hardware);
  private:
  const ::clap::pb::Hardware& _internal_hardware() const;
  ::clap::pb::Hardware* _internal_mutable_hardware();
  public:
  void unsafe_arena_set_allocated_hardware(
      ::clap::pb::Hardware* hardware);
  ::clap::pb::Hardware* unsafe_arena_release_hardware();

  // @@protoc_insertion_point(class_scope:clap.pb.Node)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  ::clap::pb::Hardware* hardware_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_clap_2eproto;
};
// -------------------------------------------------------------------

class ModelInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clap.pb.ModelInfo) */ {
 public:
  inline ModelInfo() : ModelInfo(nullptr) {}
  virtual ~ModelInfo();

  ModelInfo(const ModelInfo& from);
  ModelInfo(ModelInfo&& from) noexcept
    : ModelInfo() {
    *this = ::std::move(from);
  }

  inline ModelInfo& operator=(const ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInfo& operator=(ModelInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelInfo* internal_default_instance() {
    return reinterpret_cast<const ModelInfo*>(
               &_ModelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ModelInfo& a, ModelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelInfo* New() const final {
    return CreateMaybeMessage<ModelInfo>(nullptr);
  }

  ModelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelInfo& from);
  void MergeFrom(const ModelInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clap.pb.ModelInfo";
  }
  protected:
  explicit ModelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_clap_2eproto);
    return ::descriptor_table_clap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 version = 2;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:clap.pb.ModelInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_clap_2eproto;
};
// -------------------------------------------------------------------

class Model PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clap.pb.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  virtual ~Model();

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Model& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Model* New() const final {
    return CreateMaybeMessage<Model>(nullptr);
  }

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clap.pb.Model";
  }
  protected:
  explicit Model(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_clap_2eproto);
    return ::descriptor_table_clap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobsFieldNumber = 2,
    kInfoFieldNumber = 1,
  };
  // repeated bytes blobs = 2;
  int blobs_size() const;
  private:
  int _internal_blobs_size() const;
  public:
  void clear_blobs();
  const std::string& blobs(int index) const;
  std::string* mutable_blobs(int index);
  void set_blobs(int index, const std::string& value);
  void set_blobs(int index, std::string&& value);
  void set_blobs(int index, const char* value);
  void set_blobs(int index, const void* value, size_t size);
  std::string* add_blobs();
  void add_blobs(const std::string& value);
  void add_blobs(std::string&& value);
  void add_blobs(const char* value);
  void add_blobs(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& blobs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_blobs();
  private:
  const std::string& _internal_blobs(int index) const;
  std::string* _internal_add_blobs();
  public:

  // .clap.pb.ModelInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::clap::pb::ModelInfo& info() const;
  ::clap::pb::ModelInfo* release_info();
  ::clap::pb::ModelInfo* mutable_info();
  void set_allocated_info(::clap::pb::ModelInfo* info);
  private:
  const ::clap::pb::ModelInfo& _internal_info() const;
  ::clap::pb::ModelInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::clap::pb::ModelInfo* info);
  ::clap::pb::ModelInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:clap.pb.Model)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> blobs_;
  ::clap::pb::ModelInfo* info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_clap_2eproto;
};
// -------------------------------------------------------------------

class WorkerState_TreeOption PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clap.pb.WorkerState.TreeOption) */ {
 public:
  inline WorkerState_TreeOption() : WorkerState_TreeOption(nullptr) {}
  virtual ~WorkerState_TreeOption();

  WorkerState_TreeOption(const WorkerState_TreeOption& from);
  WorkerState_TreeOption(WorkerState_TreeOption&& from) noexcept
    : WorkerState_TreeOption() {
    *this = ::std::move(from);
  }

  inline WorkerState_TreeOption& operator=(const WorkerState_TreeOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerState_TreeOption& operator=(WorkerState_TreeOption&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WorkerState_TreeOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkerState_TreeOption* internal_default_instance() {
    return reinterpret_cast<const WorkerState_TreeOption*>(
               &_WorkerState_TreeOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WorkerState_TreeOption& a, WorkerState_TreeOption& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerState_TreeOption* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerState_TreeOption* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerState_TreeOption* New() const final {
    return CreateMaybeMessage<WorkerState_TreeOption>(nullptr);
  }

  WorkerState_TreeOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerState_TreeOption>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WorkerState_TreeOption& from);
  void MergeFrom(const WorkerState_TreeOption& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerState_TreeOption* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clap.pb.WorkerState.TreeOption";
  }
  protected:
  explicit WorkerState_TreeOption(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_clap_2eproto);
    return ::descriptor_table_clap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulationCountFieldNumber = 1,
    kTreeMinValueFieldNumber = 2,
    kTreeMaxValueFieldNumber = 3,
    kCPuctFieldNumber = 4,
    kDirichletAlphaFieldNumber = 5,
    kDirichletEpsilonFieldNumber = 6,
    kDiscountFieldNumber = 7,
  };
  // int32 simulation_count = 1;
  void clear_simulation_count();
  ::PROTOBUF_NAMESPACE_ID::int32 simulation_count() const;
  void set_simulation_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_simulation_count() const;
  void _internal_set_simulation_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float tree_min_value = 2;
  void clear_tree_min_value();
  float tree_min_value() const;
  void set_tree_min_value(float value);
  private:
  float _internal_tree_min_value() const;
  void _internal_set_tree_min_value(float value);
  public:

  // float tree_max_value = 3;
  void clear_tree_max_value();
  float tree_max_value() const;
  void set_tree_max_value(float value);
  private:
  float _internal_tree_max_value() const;
  void _internal_set_tree_max_value(float value);
  public:

  // float c_puct = 4;
  void clear_c_puct();
  float c_puct() const;
  void set_c_puct(float value);
  private:
  float _internal_c_puct() const;
  void _internal_set_c_puct(float value);
  public:

  // float dirichlet_alpha = 5;
  void clear_dirichlet_alpha();
  float dirichlet_alpha() const;
  void set_dirichlet_alpha(float value);
  private:
  float _internal_dirichlet_alpha() const;
  void _internal_set_dirichlet_alpha(float value);
  public:

  // float dirichlet_epsilon = 6;
  void clear_dirichlet_epsilon();
  float dirichlet_epsilon() const;
  void set_dirichlet_epsilon(float value);
  private:
  float _internal_dirichlet_epsilon() const;
  void _internal_set_dirichlet_epsilon(float value);
  public:

  // float discount = 7;
  void clear_discount();
  float discount() const;
  void set_discount(float value);
  private:
  float _internal_discount() const;
  void _internal_set_discount(float value);
  public:

  // @@protoc_insertion_point(class_scope:clap.pb.WorkerState.TreeOption)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 simulation_count_;
  float tree_min_value_;
  float tree_max_value_;
  float c_puct_;
  float dirichlet_alpha_;
  float dirichlet_epsilon_;
  float discount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_clap_2eproto;
};
// -------------------------------------------------------------------

class WorkerState_Evaluation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clap.pb.WorkerState.Evaluation) */ {
 public:
  inline WorkerState_Evaluation() : WorkerState_Evaluation(nullptr) {}
  virtual ~WorkerState_Evaluation();

  WorkerState_Evaluation(const WorkerState_Evaluation& from);
  WorkerState_Evaluation(WorkerState_Evaluation&& from) noexcept
    : WorkerState_Evaluation() {
    *this = ::std::move(from);
  }

  inline WorkerState_Evaluation& operator=(const WorkerState_Evaluation& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerState_Evaluation& operator=(WorkerState_Evaluation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WorkerState_Evaluation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkerState_Evaluation* internal_default_instance() {
    return reinterpret_cast<const WorkerState_Evaluation*>(
               &_WorkerState_Evaluation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(WorkerState_Evaluation& a, WorkerState_Evaluation& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerState_Evaluation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerState_Evaluation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerState_Evaluation* New() const final {
    return CreateMaybeMessage<WorkerState_Evaluation>(nullptr);
  }

  WorkerState_Evaluation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerState_Evaluation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WorkerState_Evaluation& from);
  void MergeFrom(const WorkerState_Evaluation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerState_Evaluation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clap.pb.WorkerState.Evaluation";
  }
  protected:
  explicit WorkerState_Evaluation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_clap_2eproto);
    return ::descriptor_table_clap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyFieldNumber = 2,
    kValueFieldNumber = 1,
    kAverageValueFieldNumber = 3,
  };
  // repeated float policy = 2;
  int policy_size() const;
  private:
  int _internal_policy_size() const;
  public:
  void clear_policy();
  private:
  float _internal_policy(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_policy() const;
  void _internal_add_policy(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_policy();
  public:
  float policy(int index) const;
  void set_policy(int index, float value);
  void add_policy(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      policy() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_policy();

  // float value = 1;
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // float average_value = 3;
  void clear_average_value();
  float average_value() const;
  void set_average_value(float value);
  private:
  float _internal_average_value() const;
  void _internal_set_average_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:clap.pb.WorkerState.Evaluation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > policy_;
  mutable std::atomic<int> _policy_cached_byte_size_;
  float value_;
  float average_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_clap_2eproto;
};
// -------------------------------------------------------------------

class WorkerState_Transition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clap.pb.WorkerState.Transition) */ {
 public:
  inline WorkerState_Transition() : WorkerState_Transition(nullptr) {}
  virtual ~WorkerState_Transition();

  WorkerState_Transition(const WorkerState_Transition& from);
  WorkerState_Transition(WorkerState_Transition&& from) noexcept
    : WorkerState_Transition() {
    *this = ::std::move(from);
  }

  inline WorkerState_Transition& operator=(const WorkerState_Transition& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerState_Transition& operator=(WorkerState_Transition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WorkerState_Transition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkerState_Transition* internal_default_instance() {
    return reinterpret_cast<const WorkerState_Transition*>(
               &_WorkerState_Transition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(WorkerState_Transition& a, WorkerState_Transition& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerState_Transition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerState_Transition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerState_Transition* New() const final {
    return CreateMaybeMessage<WorkerState_Transition>(nullptr);
  }

  WorkerState_Transition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerState_Transition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WorkerState_Transition& from);
  void MergeFrom(const WorkerState_Transition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerState_Transition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clap.pb.WorkerState.Transition";
  }
  protected:
  explicit WorkerState_Transition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_clap_2eproto);
    return ::descriptor_table_clap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRewardsFieldNumber = 3,
    kCurrentPlayerFieldNumber = 1,
    kActionFieldNumber = 2,
  };
  // repeated float rewards = 3;
  int rewards_size() const;
  private:
  int _internal_rewards_size() const;
  public:
  void clear_rewards();
  private:
  float _internal_rewards(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_rewards() const;
  void _internal_add_rewards(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_rewards();
  public:
  float rewards(int index) const;
  void set_rewards(int index, float value);
  void add_rewards(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      rewards() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_rewards();

  // int32 current_player = 1;
  void clear_current_player();
  ::PROTOBUF_NAMESPACE_ID::int32 current_player() const;
  void set_current_player(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_current_player() const;
  void _internal_set_current_player(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 action = 2;
  void clear_action();
  ::PROTOBUF_NAMESPACE_ID::int32 action() const;
  void set_action(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_action() const;
  void _internal_set_action(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:clap.pb.WorkerState.Transition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > rewards_;
  mutable std::atomic<int> _rewards_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 current_player_;
  ::PROTOBUF_NAMESPACE_ID::int32 action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_clap_2eproto;
};
// -------------------------------------------------------------------

class WorkerState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clap.pb.WorkerState) */ {
 public:
  inline WorkerState() : WorkerState(nullptr) {}
  virtual ~WorkerState();

  WorkerState(const WorkerState& from);
  WorkerState(WorkerState&& from) noexcept
    : WorkerState() {
    *this = ::std::move(from);
  }

  inline WorkerState& operator=(const WorkerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerState& operator=(WorkerState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WorkerState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkerState* internal_default_instance() {
    return reinterpret_cast<const WorkerState*>(
               &_WorkerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(WorkerState& a, WorkerState& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkerState* New() const final {
    return CreateMaybeMessage<WorkerState>(nullptr);
  }

  WorkerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkerState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WorkerState& from);
  void MergeFrom(const WorkerState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clap.pb.WorkerState";
  }
  protected:
  explicit WorkerState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_clap_2eproto);
    return ::descriptor_table_clap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef WorkerState_TreeOption TreeOption;
  typedef WorkerState_Evaluation Evaluation;
  typedef WorkerState_Transition Transition;

  // accessors -------------------------------------------------------

  enum : int {
    kLegalActionsFieldNumber = 1,
    kObservationTensorFieldNumber = 2,
    kTreeOptionFieldNumber = 3,
    kEvaluationFieldNumber = 4,
    kTransitionFieldNumber = 5,
  };
  // repeated int32 legal_actions = 1;
  int legal_actions_size() const;
  private:
  int _internal_legal_actions_size() const;
  public:
  void clear_legal_actions();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_legal_actions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_legal_actions() const;
  void _internal_add_legal_actions(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_legal_actions();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 legal_actions(int index) const;
  void set_legal_actions(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_legal_actions(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      legal_actions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_legal_actions();

  // repeated float observation_tensor = 2;
  int observation_tensor_size() const;
  private:
  int _internal_observation_tensor_size() const;
  public:
  void clear_observation_tensor();
  private:
  float _internal_observation_tensor(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_observation_tensor() const;
  void _internal_add_observation_tensor(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_observation_tensor();
  public:
  float observation_tensor(int index) const;
  void set_observation_tensor(int index, float value);
  void add_observation_tensor(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      observation_tensor() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_observation_tensor();

  // .clap.pb.WorkerState.TreeOption tree_option = 3;
  bool has_tree_option() const;
  private:
  bool _internal_has_tree_option() const;
  public:
  void clear_tree_option();
  const ::clap::pb::WorkerState_TreeOption& tree_option() const;
  ::clap::pb::WorkerState_TreeOption* release_tree_option();
  ::clap::pb::WorkerState_TreeOption* mutable_tree_option();
  void set_allocated_tree_option(::clap::pb::WorkerState_TreeOption* tree_option);
  private:
  const ::clap::pb::WorkerState_TreeOption& _internal_tree_option() const;
  ::clap::pb::WorkerState_TreeOption* _internal_mutable_tree_option();
  public:
  void unsafe_arena_set_allocated_tree_option(
      ::clap::pb::WorkerState_TreeOption* tree_option);
  ::clap::pb::WorkerState_TreeOption* unsafe_arena_release_tree_option();

  // .clap.pb.WorkerState.Evaluation evaluation = 4;
  bool has_evaluation() const;
  private:
  bool _internal_has_evaluation() const;
  public:
  void clear_evaluation();
  const ::clap::pb::WorkerState_Evaluation& evaluation() const;
  ::clap::pb::WorkerState_Evaluation* release_evaluation();
  ::clap::pb::WorkerState_Evaluation* mutable_evaluation();
  void set_allocated_evaluation(::clap::pb::WorkerState_Evaluation* evaluation);
  private:
  const ::clap::pb::WorkerState_Evaluation& _internal_evaluation() const;
  ::clap::pb::WorkerState_Evaluation* _internal_mutable_evaluation();
  public:
  void unsafe_arena_set_allocated_evaluation(
      ::clap::pb::WorkerState_Evaluation* evaluation);
  ::clap::pb::WorkerState_Evaluation* unsafe_arena_release_evaluation();

  // .clap.pb.WorkerState.Transition transition = 5;
  bool has_transition() const;
  private:
  bool _internal_has_transition() const;
  public:
  void clear_transition();
  const ::clap::pb::WorkerState_Transition& transition() const;
  ::clap::pb::WorkerState_Transition* release_transition();
  ::clap::pb::WorkerState_Transition* mutable_transition();
  void set_allocated_transition(::clap::pb::WorkerState_Transition* transition);
  private:
  const ::clap::pb::WorkerState_Transition& _internal_transition() const;
  ::clap::pb::WorkerState_Transition* _internal_mutable_transition();
  public:
  void unsafe_arena_set_allocated_transition(
      ::clap::pb::WorkerState_Transition* transition);
  ::clap::pb::WorkerState_Transition* unsafe_arena_release_transition();

  // @@protoc_insertion_point(class_scope:clap.pb.WorkerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > legal_actions_;
  mutable std::atomic<int> _legal_actions_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > observation_tensor_;
  mutable std::atomic<int> _observation_tensor_cached_byte_size_;
  ::clap::pb::WorkerState_TreeOption* tree_option_;
  ::clap::pb::WorkerState_Evaluation* evaluation_;
  ::clap::pb::WorkerState_Transition* transition_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_clap_2eproto;
};
// -------------------------------------------------------------------

class Trajectory_Statistics PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clap.pb.Trajectory.Statistics) */ {
 public:
  inline Trajectory_Statistics() : Trajectory_Statistics(nullptr) {}
  virtual ~Trajectory_Statistics();

  Trajectory_Statistics(const Trajectory_Statistics& from);
  Trajectory_Statistics(Trajectory_Statistics&& from) noexcept
    : Trajectory_Statistics() {
    *this = ::std::move(from);
  }

  inline Trajectory_Statistics& operator=(const Trajectory_Statistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trajectory_Statistics& operator=(Trajectory_Statistics&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Trajectory_Statistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trajectory_Statistics* internal_default_instance() {
    return reinterpret_cast<const Trajectory_Statistics*>(
               &_Trajectory_Statistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Trajectory_Statistics& a, Trajectory_Statistics& b) {
    a.Swap(&b);
  }
  inline void Swap(Trajectory_Statistics* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trajectory_Statistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Trajectory_Statistics* New() const final {
    return CreateMaybeMessage<Trajectory_Statistics>(nullptr);
  }

  Trajectory_Statistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Trajectory_Statistics>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Trajectory_Statistics& from);
  void MergeFrom(const Trajectory_Statistics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trajectory_Statistics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clap.pb.Trajectory.Statistics";
  }
  protected:
  explicit Trajectory_Statistics(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_clap_2eproto);
    return ::descriptor_table_clap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRewardsFieldNumber = 1,
    kGameStepsFieldNumber = 2,
  };
  // repeated float rewards = 1;
  int rewards_size() const;
  private:
  int _internal_rewards_size() const;
  public:
  void clear_rewards();
  private:
  float _internal_rewards(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_rewards() const;
  void _internal_add_rewards(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_rewards();
  public:
  float rewards(int index) const;
  void set_rewards(int index, float value);
  void add_rewards(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      rewards() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_rewards();

  // int32 game_steps = 2;
  void clear_game_steps();
  ::PROTOBUF_NAMESPACE_ID::int32 game_steps() const;
  void set_game_steps(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_game_steps() const;
  void _internal_set_game_steps(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:clap.pb.Trajectory.Statistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > rewards_;
  mutable std::atomic<int> _rewards_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 game_steps_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_clap_2eproto;
};
// -------------------------------------------------------------------

class Trajectory PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clap.pb.Trajectory) */ {
 public:
  inline Trajectory() : Trajectory(nullptr) {}
  virtual ~Trajectory();

  Trajectory(const Trajectory& from);
  Trajectory(Trajectory&& from) noexcept
    : Trajectory() {
    *this = ::std::move(from);
  }

  inline Trajectory& operator=(const Trajectory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trajectory& operator=(Trajectory&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Trajectory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trajectory* internal_default_instance() {
    return reinterpret_cast<const Trajectory*>(
               &_Trajectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Trajectory& a, Trajectory& b) {
    a.Swap(&b);
  }
  inline void Swap(Trajectory* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trajectory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Trajectory* New() const final {
    return CreateMaybeMessage<Trajectory>(nullptr);
  }

  Trajectory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Trajectory>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Trajectory& from);
  void MergeFrom(const Trajectory& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trajectory* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clap.pb.Trajectory";
  }
  protected:
  explicit Trajectory(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_clap_2eproto);
    return ::descriptor_table_clap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Trajectory_Statistics Statistics;

  // accessors -------------------------------------------------------

  enum : int {
    kStatesFieldNumber = 1,
    kAppendixFieldNumber = 3,
    kStatisticsFieldNumber = 2,
  };
  // repeated .clap.pb.WorkerState states = 1;
  int states_size() const;
  private:
  int _internal_states_size() const;
  public:
  void clear_states();
  ::clap::pb::WorkerState* mutable_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::WorkerState >*
      mutable_states();
  private:
  const ::clap::pb::WorkerState& _internal_states(int index) const;
  ::clap::pb::WorkerState* _internal_add_states();
  public:
  const ::clap::pb::WorkerState& states(int index) const;
  ::clap::pb::WorkerState* add_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::WorkerState >&
      states() const;

  // string appendix = 3;
  void clear_appendix();
  const std::string& appendix() const;
  void set_appendix(const std::string& value);
  void set_appendix(std::string&& value);
  void set_appendix(const char* value);
  void set_appendix(const char* value, size_t size);
  std::string* mutable_appendix();
  std::string* release_appendix();
  void set_allocated_appendix(std::string* appendix);
  private:
  const std::string& _internal_appendix() const;
  void _internal_set_appendix(const std::string& value);
  std::string* _internal_mutable_appendix();
  public:

  // .clap.pb.Trajectory.Statistics statistics = 2;
  bool has_statistics() const;
  private:
  bool _internal_has_statistics() const;
  public:
  void clear_statistics();
  const ::clap::pb::Trajectory_Statistics& statistics() const;
  ::clap::pb::Trajectory_Statistics* release_statistics();
  ::clap::pb::Trajectory_Statistics* mutable_statistics();
  void set_allocated_statistics(::clap::pb::Trajectory_Statistics* statistics);
  private:
  const ::clap::pb::Trajectory_Statistics& _internal_statistics() const;
  ::clap::pb::Trajectory_Statistics* _internal_mutable_statistics();
  public:
  void unsafe_arena_set_allocated_statistics(
      ::clap::pb::Trajectory_Statistics* statistics);
  ::clap::pb::Trajectory_Statistics* unsafe_arena_release_statistics();

  // @@protoc_insertion_point(class_scope:clap.pb.Trajectory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::WorkerState > states_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appendix_;
  ::clap::pb::Trajectory_Statistics* statistics_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_clap_2eproto;
};
// -------------------------------------------------------------------

class Trajectories PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clap.pb.Trajectories) */ {
 public:
  inline Trajectories() : Trajectories(nullptr) {}
  virtual ~Trajectories();

  Trajectories(const Trajectories& from);
  Trajectories(Trajectories&& from) noexcept
    : Trajectories() {
    *this = ::std::move(from);
  }

  inline Trajectories& operator=(const Trajectories& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trajectories& operator=(Trajectories&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Trajectories& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trajectories* internal_default_instance() {
    return reinterpret_cast<const Trajectories*>(
               &_Trajectories_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Trajectories& a, Trajectories& b) {
    a.Swap(&b);
  }
  inline void Swap(Trajectories* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trajectories* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Trajectories* New() const final {
    return CreateMaybeMessage<Trajectories>(nullptr);
  }

  Trajectories* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Trajectories>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Trajectories& from);
  void MergeFrom(const Trajectories& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trajectories* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clap.pb.Trajectories";
  }
  protected:
  explicit Trajectories(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_clap_2eproto);
    return ::descriptor_table_clap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajectoriesFieldNumber = 1,
  };
  // repeated .clap.pb.Trajectory trajectories = 1;
  int trajectories_size() const;
  private:
  int _internal_trajectories_size() const;
  public:
  void clear_trajectories();
  ::clap::pb::Trajectory* mutable_trajectories(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::Trajectory >*
      mutable_trajectories();
  private:
  const ::clap::pb::Trajectory& _internal_trajectories(int index) const;
  ::clap::pb::Trajectory* _internal_add_trajectories();
  public:
  const ::clap::pb::Trajectory& trajectories(int index) const;
  ::clap::pb::Trajectory* add_trajectories();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::Trajectory >&
      trajectories() const;

  // @@protoc_insertion_point(class_scope:clap.pb.Trajectories)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::Trajectory > trajectories_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_clap_2eproto;
};
// -------------------------------------------------------------------

class Heartbeat PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clap.pb.Heartbeat) */ {
 public:
  inline Heartbeat() : Heartbeat(nullptr) {}
  virtual ~Heartbeat();

  Heartbeat(const Heartbeat& from);
  Heartbeat(Heartbeat&& from) noexcept
    : Heartbeat() {
    *this = ::std::move(from);
  }

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Heartbeat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Heartbeat* internal_default_instance() {
    return reinterpret_cast<const Heartbeat*>(
               &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Heartbeat& a, Heartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(Heartbeat* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heartbeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Heartbeat* New() const final {
    return CreateMaybeMessage<Heartbeat>(nullptr);
  }

  Heartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Heartbeat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Heartbeat& from);
  void MergeFrom(const Heartbeat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Heartbeat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clap.pb.Heartbeat";
  }
  protected:
  explicit Heartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_clap_2eproto);
    return ::descriptor_table_clap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:clap.pb.Heartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_clap_2eproto;
};
// -------------------------------------------------------------------

class Packet PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:clap.pb.Packet) */ {
 public:
  inline Packet() : Packet(nullptr) {}
  virtual ~Packet();

  Packet(const Packet& from);
  Packet(Packet&& from) noexcept
    : Packet() {
    *this = ::std::move(from);
  }

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Packet& operator=(Packet&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Packet& default_instance();

  enum PayloadCase {
    kHeartbeat = 1,
    kGoodbye = 2,
    kModelSubscribe = 3,
    kModelInfo = 4,
    kModelRequest = 5,
    kModelResponse = 6,
    kTrajectory = 7,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Packet* internal_default_instance() {
    return reinterpret_cast<const Packet*>(
               &_Packet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Packet& a, Packet& b) {
    a.Swap(&b);
  }
  inline void Swap(Packet* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Packet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Packet* New() const final {
    return CreateMaybeMessage<Packet>(nullptr);
  }

  Packet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Packet>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Packet& from);
  void MergeFrom(const Packet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Packet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "clap.pb.Packet";
  }
  protected:
  explicit Packet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_clap_2eproto);
    return ::descriptor_table_clap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeartbeatFieldNumber = 1,
    kGoodbyeFieldNumber = 2,
    kModelSubscribeFieldNumber = 3,
    kModelInfoFieldNumber = 4,
    kModelRequestFieldNumber = 5,
    kModelResponseFieldNumber = 6,
    kTrajectoryFieldNumber = 7,
  };
  // .clap.pb.Heartbeat heartbeat = 1;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;
  public:
  void clear_heartbeat();
  const ::clap::pb::Heartbeat& heartbeat() const;
  ::clap::pb::Heartbeat* release_heartbeat();
  ::clap::pb::Heartbeat* mutable_heartbeat();
  void set_allocated_heartbeat(::clap::pb::Heartbeat* heartbeat);
  private:
  const ::clap::pb::Heartbeat& _internal_heartbeat() const;
  ::clap::pb::Heartbeat* _internal_mutable_heartbeat();
  public:
  void unsafe_arena_set_allocated_heartbeat(
      ::clap::pb::Heartbeat* heartbeat);
  ::clap::pb::Heartbeat* unsafe_arena_release_heartbeat();

  // .clap.pb.Heartbeat goodbye = 2;
  bool has_goodbye() const;
  private:
  bool _internal_has_goodbye() const;
  public:
  void clear_goodbye();
  const ::clap::pb::Heartbeat& goodbye() const;
  ::clap::pb::Heartbeat* release_goodbye();
  ::clap::pb::Heartbeat* mutable_goodbye();
  void set_allocated_goodbye(::clap::pb::Heartbeat* goodbye);
  private:
  const ::clap::pb::Heartbeat& _internal_goodbye() const;
  ::clap::pb::Heartbeat* _internal_mutable_goodbye();
  public:
  void unsafe_arena_set_allocated_goodbye(
      ::clap::pb::Heartbeat* goodbye);
  ::clap::pb::Heartbeat* unsafe_arena_release_goodbye();

  // .clap.pb.Heartbeat model_subscribe = 3;
  bool has_model_subscribe() const;
  private:
  bool _internal_has_model_subscribe() const;
  public:
  void clear_model_subscribe();
  const ::clap::pb::Heartbeat& model_subscribe() const;
  ::clap::pb::Heartbeat* release_model_subscribe();
  ::clap::pb::Heartbeat* mutable_model_subscribe();
  void set_allocated_model_subscribe(::clap::pb::Heartbeat* model_subscribe);
  private:
  const ::clap::pb::Heartbeat& _internal_model_subscribe() const;
  ::clap::pb::Heartbeat* _internal_mutable_model_subscribe();
  public:
  void unsafe_arena_set_allocated_model_subscribe(
      ::clap::pb::Heartbeat* model_subscribe);
  ::clap::pb::Heartbeat* unsafe_arena_release_model_subscribe();

  // .clap.pb.ModelInfo model_info = 4;
  bool has_model_info() const;
  private:
  bool _internal_has_model_info() const;
  public:
  void clear_model_info();
  const ::clap::pb::ModelInfo& model_info() const;
  ::clap::pb::ModelInfo* release_model_info();
  ::clap::pb::ModelInfo* mutable_model_info();
  void set_allocated_model_info(::clap::pb::ModelInfo* model_info);
  private:
  const ::clap::pb::ModelInfo& _internal_model_info() const;
  ::clap::pb::ModelInfo* _internal_mutable_model_info();
  public:
  void unsafe_arena_set_allocated_model_info(
      ::clap::pb::ModelInfo* model_info);
  ::clap::pb::ModelInfo* unsafe_arena_release_model_info();

  // .clap.pb.ModelInfo model_request = 5;
  bool has_model_request() const;
  private:
  bool _internal_has_model_request() const;
  public:
  void clear_model_request();
  const ::clap::pb::ModelInfo& model_request() const;
  ::clap::pb::ModelInfo* release_model_request();
  ::clap::pb::ModelInfo* mutable_model_request();
  void set_allocated_model_request(::clap::pb::ModelInfo* model_request);
  private:
  const ::clap::pb::ModelInfo& _internal_model_request() const;
  ::clap::pb::ModelInfo* _internal_mutable_model_request();
  public:
  void unsafe_arena_set_allocated_model_request(
      ::clap::pb::ModelInfo* model_request);
  ::clap::pb::ModelInfo* unsafe_arena_release_model_request();

  // .clap.pb.Model model_response = 6;
  bool has_model_response() const;
  private:
  bool _internal_has_model_response() const;
  public:
  void clear_model_response();
  const ::clap::pb::Model& model_response() const;
  ::clap::pb::Model* release_model_response();
  ::clap::pb::Model* mutable_model_response();
  void set_allocated_model_response(::clap::pb::Model* model_response);
  private:
  const ::clap::pb::Model& _internal_model_response() const;
  ::clap::pb::Model* _internal_mutable_model_response();
  public:
  void unsafe_arena_set_allocated_model_response(
      ::clap::pb::Model* model_response);
  ::clap::pb::Model* unsafe_arena_release_model_response();

  // .clap.pb.Trajectory trajectory = 7;
  bool has_trajectory() const;
  private:
  bool _internal_has_trajectory() const;
  public:
  void clear_trajectory();
  const ::clap::pb::Trajectory& trajectory() const;
  ::clap::pb::Trajectory* release_trajectory();
  ::clap::pb::Trajectory* mutable_trajectory();
  void set_allocated_trajectory(::clap::pb::Trajectory* trajectory);
  private:
  const ::clap::pb::Trajectory& _internal_trajectory() const;
  ::clap::pb::Trajectory* _internal_mutable_trajectory();
  public:
  void unsafe_arena_set_allocated_trajectory(
      ::clap::pb::Trajectory* trajectory);
  ::clap::pb::Trajectory* unsafe_arena_release_trajectory();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:clap.pb.Packet)
 private:
  class _Internal;
  void set_has_heartbeat();
  void set_has_goodbye();
  void set_has_model_subscribe();
  void set_has_model_info();
  void set_has_model_request();
  void set_has_model_response();
  void set_has_trajectory();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PayloadUnion {
    PayloadUnion() {}
    ::clap::pb::Heartbeat* heartbeat_;
    ::clap::pb::Heartbeat* goodbye_;
    ::clap::pb::Heartbeat* model_subscribe_;
    ::clap::pb::ModelInfo* model_info_;
    ::clap::pb::ModelInfo* model_request_;
    ::clap::pb::Model* model_response_;
    ::clap::pb::Trajectory* trajectory_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_clap_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CPU

// string name = 1;
inline void CPU::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CPU::name() const {
  // @@protoc_insertion_point(field_get:clap.pb.CPU.name)
  return _internal_name();
}
inline void CPU::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:clap.pb.CPU.name)
}
inline std::string* CPU::mutable_name() {
  // @@protoc_insertion_point(field_mutable:clap.pb.CPU.name)
  return _internal_mutable_name();
}
inline const std::string& CPU::_internal_name() const {
  return name_.Get();
}
inline void CPU::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CPU::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:clap.pb.CPU.name)
}
inline void CPU::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:clap.pb.CPU.name)
}
inline void CPU::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:clap.pb.CPU.name)
}
inline std::string* CPU::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CPU::release_name() {
  // @@protoc_insertion_point(field_release:clap.pb.CPU.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CPU::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:clap.pb.CPU.name)
}

// int32 cores = 2;
inline void CPU::clear_cores() {
  cores_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CPU::_internal_cores() const {
  return cores_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CPU::cores() const {
  // @@protoc_insertion_point(field_get:clap.pb.CPU.cores)
  return _internal_cores();
}
inline void CPU::_internal_set_cores(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cores_ = value;
}
inline void CPU::set_cores(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cores(value);
  // @@protoc_insertion_point(field_set:clap.pb.CPU.cores)
}

// int32 threads = 3;
inline void CPU::clear_threads() {
  threads_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CPU::_internal_threads() const {
  return threads_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CPU::threads() const {
  // @@protoc_insertion_point(field_get:clap.pb.CPU.threads)
  return _internal_threads();
}
inline void CPU::_internal_set_threads(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  threads_ = value;
}
inline void CPU::set_threads(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_threads(value);
  // @@protoc_insertion_point(field_set:clap.pb.CPU.threads)
}

// float clock = 4;
inline void CPU::clear_clock() {
  clock_ = 0;
}
inline float CPU::_internal_clock() const {
  return clock_;
}
inline float CPU::clock() const {
  // @@protoc_insertion_point(field_get:clap.pb.CPU.clock)
  return _internal_clock();
}
inline void CPU::_internal_set_clock(float value) {
  
  clock_ = value;
}
inline void CPU::set_clock(float value) {
  _internal_set_clock(value);
  // @@protoc_insertion_point(field_set:clap.pb.CPU.clock)
}

// -------------------------------------------------------------------

// GPU

// string name = 1;
inline void GPU::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GPU::name() const {
  // @@protoc_insertion_point(field_get:clap.pb.GPU.name)
  return _internal_name();
}
inline void GPU::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:clap.pb.GPU.name)
}
inline std::string* GPU::mutable_name() {
  // @@protoc_insertion_point(field_mutable:clap.pb.GPU.name)
  return _internal_mutable_name();
}
inline const std::string& GPU::_internal_name() const {
  return name_.Get();
}
inline void GPU::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GPU::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:clap.pb.GPU.name)
}
inline void GPU::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:clap.pb.GPU.name)
}
inline void GPU::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:clap.pb.GPU.name)
}
inline std::string* GPU::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GPU::release_name() {
  // @@protoc_insertion_point(field_release:clap.pb.GPU.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GPU::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:clap.pb.GPU.name)
}

// int64 memory = 2;
inline void GPU::clear_memory() {
  memory_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GPU::_internal_memory() const {
  return memory_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GPU::memory() const {
  // @@protoc_insertion_point(field_get:clap.pb.GPU.memory)
  return _internal_memory();
}
inline void GPU::_internal_set_memory(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  memory_ = value;
}
inline void GPU::set_memory(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_memory(value);
  // @@protoc_insertion_point(field_set:clap.pb.GPU.memory)
}

// -------------------------------------------------------------------

// Hardware

// repeated .clap.pb.CPU cpus = 1;
inline int Hardware::_internal_cpus_size() const {
  return cpus_.size();
}
inline int Hardware::cpus_size() const {
  return _internal_cpus_size();
}
inline void Hardware::clear_cpus() {
  cpus_.Clear();
}
inline ::clap::pb::CPU* Hardware::mutable_cpus(int index) {
  // @@protoc_insertion_point(field_mutable:clap.pb.Hardware.cpus)
  return cpus_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::CPU >*
Hardware::mutable_cpus() {
  // @@protoc_insertion_point(field_mutable_list:clap.pb.Hardware.cpus)
  return &cpus_;
}
inline const ::clap::pb::CPU& Hardware::_internal_cpus(int index) const {
  return cpus_.Get(index);
}
inline const ::clap::pb::CPU& Hardware::cpus(int index) const {
  // @@protoc_insertion_point(field_get:clap.pb.Hardware.cpus)
  return _internal_cpus(index);
}
inline ::clap::pb::CPU* Hardware::_internal_add_cpus() {
  return cpus_.Add();
}
inline ::clap::pb::CPU* Hardware::add_cpus() {
  // @@protoc_insertion_point(field_add:clap.pb.Hardware.cpus)
  return _internal_add_cpus();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::CPU >&
Hardware::cpus() const {
  // @@protoc_insertion_point(field_list:clap.pb.Hardware.cpus)
  return cpus_;
}

// repeated .clap.pb.GPU gpus = 2;
inline int Hardware::_internal_gpus_size() const {
  return gpus_.size();
}
inline int Hardware::gpus_size() const {
  return _internal_gpus_size();
}
inline void Hardware::clear_gpus() {
  gpus_.Clear();
}
inline ::clap::pb::GPU* Hardware::mutable_gpus(int index) {
  // @@protoc_insertion_point(field_mutable:clap.pb.Hardware.gpus)
  return gpus_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::GPU >*
Hardware::mutable_gpus() {
  // @@protoc_insertion_point(field_mutable_list:clap.pb.Hardware.gpus)
  return &gpus_;
}
inline const ::clap::pb::GPU& Hardware::_internal_gpus(int index) const {
  return gpus_.Get(index);
}
inline const ::clap::pb::GPU& Hardware::gpus(int index) const {
  // @@protoc_insertion_point(field_get:clap.pb.Hardware.gpus)
  return _internal_gpus(index);
}
inline ::clap::pb::GPU* Hardware::_internal_add_gpus() {
  return gpus_.Add();
}
inline ::clap::pb::GPU* Hardware::add_gpus() {
  // @@protoc_insertion_point(field_add:clap.pb.Hardware.gpus)
  return _internal_add_gpus();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::GPU >&
Hardware::gpus() const {
  // @@protoc_insertion_point(field_list:clap.pb.Hardware.gpus)
  return gpus_;
}

// -------------------------------------------------------------------

// Node

// string identity = 1;
inline void Node::clear_identity() {
  identity_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Node::identity() const {
  // @@protoc_insertion_point(field_get:clap.pb.Node.identity)
  return _internal_identity();
}
inline void Node::set_identity(const std::string& value) {
  _internal_set_identity(value);
  // @@protoc_insertion_point(field_set:clap.pb.Node.identity)
}
inline std::string* Node::mutable_identity() {
  // @@protoc_insertion_point(field_mutable:clap.pb.Node.identity)
  return _internal_mutable_identity();
}
inline const std::string& Node::_internal_identity() const {
  return identity_.Get();
}
inline void Node::_internal_set_identity(const std::string& value) {
  
  identity_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Node::set_identity(std::string&& value) {
  
  identity_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:clap.pb.Node.identity)
}
inline void Node::set_identity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  identity_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:clap.pb.Node.identity)
}
inline void Node::set_identity(const char* value,
    size_t size) {
  
  identity_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:clap.pb.Node.identity)
}
inline std::string* Node::_internal_mutable_identity() {
  
  return identity_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Node::release_identity() {
  // @@protoc_insertion_point(field_release:clap.pb.Node.identity)
  return identity_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Node::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  identity_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identity,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:clap.pb.Node.identity)
}

// string hostname = 2;
inline void Node::clear_hostname() {
  hostname_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Node::hostname() const {
  // @@protoc_insertion_point(field_get:clap.pb.Node.hostname)
  return _internal_hostname();
}
inline void Node::set_hostname(const std::string& value) {
  _internal_set_hostname(value);
  // @@protoc_insertion_point(field_set:clap.pb.Node.hostname)
}
inline std::string* Node::mutable_hostname() {
  // @@protoc_insertion_point(field_mutable:clap.pb.Node.hostname)
  return _internal_mutable_hostname();
}
inline const std::string& Node::_internal_hostname() const {
  return hostname_.Get();
}
inline void Node::_internal_set_hostname(const std::string& value) {
  
  hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Node::set_hostname(std::string&& value) {
  
  hostname_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:clap.pb.Node.hostname)
}
inline void Node::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:clap.pb.Node.hostname)
}
inline void Node::set_hostname(const char* value,
    size_t size) {
  
  hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:clap.pb.Node.hostname)
}
inline std::string* Node::_internal_mutable_hostname() {
  
  return hostname_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Node::release_hostname() {
  // @@protoc_insertion_point(field_release:clap.pb.Node.hostname)
  return hostname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Node::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  hostname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:clap.pb.Node.hostname)
}

// .clap.pb.Hardware hardware = 3;
inline bool Node::_internal_has_hardware() const {
  return this != internal_default_instance() && hardware_ != nullptr;
}
inline bool Node::has_hardware() const {
  return _internal_has_hardware();
}
inline void Node::clear_hardware() {
  if (GetArena() == nullptr && hardware_ != nullptr) {
    delete hardware_;
  }
  hardware_ = nullptr;
}
inline const ::clap::pb::Hardware& Node::_internal_hardware() const {
  const ::clap::pb::Hardware* p = hardware_;
  return p != nullptr ? *p : *reinterpret_cast<const ::clap::pb::Hardware*>(
      &::clap::pb::_Hardware_default_instance_);
}
inline const ::clap::pb::Hardware& Node::hardware() const {
  // @@protoc_insertion_point(field_get:clap.pb.Node.hardware)
  return _internal_hardware();
}
inline void Node::unsafe_arena_set_allocated_hardware(
    ::clap::pb::Hardware* hardware) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hardware_);
  }
  hardware_ = hardware;
  if (hardware) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clap.pb.Node.hardware)
}
inline ::clap::pb::Hardware* Node::release_hardware() {
  
  ::clap::pb::Hardware* temp = hardware_;
  hardware_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::clap::pb::Hardware* Node::unsafe_arena_release_hardware() {
  // @@protoc_insertion_point(field_release:clap.pb.Node.hardware)
  
  ::clap::pb::Hardware* temp = hardware_;
  hardware_ = nullptr;
  return temp;
}
inline ::clap::pb::Hardware* Node::_internal_mutable_hardware() {
  
  if (hardware_ == nullptr) {
    auto* p = CreateMaybeMessage<::clap::pb::Hardware>(GetArena());
    hardware_ = p;
  }
  return hardware_;
}
inline ::clap::pb::Hardware* Node::mutable_hardware() {
  // @@protoc_insertion_point(field_mutable:clap.pb.Node.hardware)
  return _internal_mutable_hardware();
}
inline void Node::set_allocated_hardware(::clap::pb::Hardware* hardware) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hardware_;
  }
  if (hardware) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hardware);
    if (message_arena != submessage_arena) {
      hardware = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hardware, submessage_arena);
    }
    
  } else {
    
  }
  hardware_ = hardware;
  // @@protoc_insertion_point(field_set_allocated:clap.pb.Node.hardware)
}

// -------------------------------------------------------------------

// ModelInfo

// string name = 1;
inline void ModelInfo::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ModelInfo::name() const {
  // @@protoc_insertion_point(field_get:clap.pb.ModelInfo.name)
  return _internal_name();
}
inline void ModelInfo::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:clap.pb.ModelInfo.name)
}
inline std::string* ModelInfo::mutable_name() {
  // @@protoc_insertion_point(field_mutable:clap.pb.ModelInfo.name)
  return _internal_mutable_name();
}
inline const std::string& ModelInfo::_internal_name() const {
  return name_.Get();
}
inline void ModelInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ModelInfo::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:clap.pb.ModelInfo.name)
}
inline void ModelInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:clap.pb.ModelInfo.name)
}
inline void ModelInfo::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:clap.pb.ModelInfo.name)
}
inline std::string* ModelInfo::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ModelInfo::release_name() {
  // @@protoc_insertion_point(field_release:clap.pb.ModelInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ModelInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:clap.pb.ModelInfo.name)
}

// int32 version = 2;
inline void ModelInfo::clear_version() {
  version_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelInfo::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModelInfo::version() const {
  // @@protoc_insertion_point(field_get:clap.pb.ModelInfo.version)
  return _internal_version();
}
inline void ModelInfo::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  version_ = value;
}
inline void ModelInfo::set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:clap.pb.ModelInfo.version)
}

// -------------------------------------------------------------------

// Model

// .clap.pb.ModelInfo info = 1;
inline bool Model::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool Model::has_info() const {
  return _internal_has_info();
}
inline void Model::clear_info() {
  if (GetArena() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::clap::pb::ModelInfo& Model::_internal_info() const {
  const ::clap::pb::ModelInfo* p = info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::clap::pb::ModelInfo*>(
      &::clap::pb::_ModelInfo_default_instance_);
}
inline const ::clap::pb::ModelInfo& Model::info() const {
  // @@protoc_insertion_point(field_get:clap.pb.Model.info)
  return _internal_info();
}
inline void Model::unsafe_arena_set_allocated_info(
    ::clap::pb::ModelInfo* info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clap.pb.Model.info)
}
inline ::clap::pb::ModelInfo* Model::release_info() {
  
  ::clap::pb::ModelInfo* temp = info_;
  info_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::clap::pb::ModelInfo* Model::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:clap.pb.Model.info)
  
  ::clap::pb::ModelInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::clap::pb::ModelInfo* Model::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::clap::pb::ModelInfo>(GetArena());
    info_ = p;
  }
  return info_;
}
inline ::clap::pb::ModelInfo* Model::mutable_info() {
  // @@protoc_insertion_point(field_mutable:clap.pb.Model.info)
  return _internal_mutable_info();
}
inline void Model::set_allocated_info(::clap::pb::ModelInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:clap.pb.Model.info)
}

// repeated bytes blobs = 2;
inline int Model::_internal_blobs_size() const {
  return blobs_.size();
}
inline int Model::blobs_size() const {
  return _internal_blobs_size();
}
inline void Model::clear_blobs() {
  blobs_.Clear();
}
inline std::string* Model::add_blobs() {
  // @@protoc_insertion_point(field_add_mutable:clap.pb.Model.blobs)
  return _internal_add_blobs();
}
inline const std::string& Model::_internal_blobs(int index) const {
  return blobs_.Get(index);
}
inline const std::string& Model::blobs(int index) const {
  // @@protoc_insertion_point(field_get:clap.pb.Model.blobs)
  return _internal_blobs(index);
}
inline std::string* Model::mutable_blobs(int index) {
  // @@protoc_insertion_point(field_mutable:clap.pb.Model.blobs)
  return blobs_.Mutable(index);
}
inline void Model::set_blobs(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:clap.pb.Model.blobs)
  blobs_.Mutable(index)->assign(value);
}
inline void Model::set_blobs(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:clap.pb.Model.blobs)
  blobs_.Mutable(index)->assign(std::move(value));
}
inline void Model::set_blobs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  blobs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:clap.pb.Model.blobs)
}
inline void Model::set_blobs(int index, const void* value, size_t size) {
  blobs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:clap.pb.Model.blobs)
}
inline std::string* Model::_internal_add_blobs() {
  return blobs_.Add();
}
inline void Model::add_blobs(const std::string& value) {
  blobs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:clap.pb.Model.blobs)
}
inline void Model::add_blobs(std::string&& value) {
  blobs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:clap.pb.Model.blobs)
}
inline void Model::add_blobs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  blobs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:clap.pb.Model.blobs)
}
inline void Model::add_blobs(const void* value, size_t size) {
  blobs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:clap.pb.Model.blobs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Model::blobs() const {
  // @@protoc_insertion_point(field_list:clap.pb.Model.blobs)
  return blobs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Model::mutable_blobs() {
  // @@protoc_insertion_point(field_mutable_list:clap.pb.Model.blobs)
  return &blobs_;
}

// -------------------------------------------------------------------

// WorkerState_TreeOption

// int32 simulation_count = 1;
inline void WorkerState_TreeOption::clear_simulation_count() {
  simulation_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WorkerState_TreeOption::_internal_simulation_count() const {
  return simulation_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WorkerState_TreeOption::simulation_count() const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.TreeOption.simulation_count)
  return _internal_simulation_count();
}
inline void WorkerState_TreeOption::_internal_set_simulation_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  simulation_count_ = value;
}
inline void WorkerState_TreeOption::set_simulation_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_simulation_count(value);
  // @@protoc_insertion_point(field_set:clap.pb.WorkerState.TreeOption.simulation_count)
}

// float tree_min_value = 2;
inline void WorkerState_TreeOption::clear_tree_min_value() {
  tree_min_value_ = 0;
}
inline float WorkerState_TreeOption::_internal_tree_min_value() const {
  return tree_min_value_;
}
inline float WorkerState_TreeOption::tree_min_value() const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.TreeOption.tree_min_value)
  return _internal_tree_min_value();
}
inline void WorkerState_TreeOption::_internal_set_tree_min_value(float value) {
  
  tree_min_value_ = value;
}
inline void WorkerState_TreeOption::set_tree_min_value(float value) {
  _internal_set_tree_min_value(value);
  // @@protoc_insertion_point(field_set:clap.pb.WorkerState.TreeOption.tree_min_value)
}

// float tree_max_value = 3;
inline void WorkerState_TreeOption::clear_tree_max_value() {
  tree_max_value_ = 0;
}
inline float WorkerState_TreeOption::_internal_tree_max_value() const {
  return tree_max_value_;
}
inline float WorkerState_TreeOption::tree_max_value() const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.TreeOption.tree_max_value)
  return _internal_tree_max_value();
}
inline void WorkerState_TreeOption::_internal_set_tree_max_value(float value) {
  
  tree_max_value_ = value;
}
inline void WorkerState_TreeOption::set_tree_max_value(float value) {
  _internal_set_tree_max_value(value);
  // @@protoc_insertion_point(field_set:clap.pb.WorkerState.TreeOption.tree_max_value)
}

// float c_puct = 4;
inline void WorkerState_TreeOption::clear_c_puct() {
  c_puct_ = 0;
}
inline float WorkerState_TreeOption::_internal_c_puct() const {
  return c_puct_;
}
inline float WorkerState_TreeOption::c_puct() const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.TreeOption.c_puct)
  return _internal_c_puct();
}
inline void WorkerState_TreeOption::_internal_set_c_puct(float value) {
  
  c_puct_ = value;
}
inline void WorkerState_TreeOption::set_c_puct(float value) {
  _internal_set_c_puct(value);
  // @@protoc_insertion_point(field_set:clap.pb.WorkerState.TreeOption.c_puct)
}

// float dirichlet_alpha = 5;
inline void WorkerState_TreeOption::clear_dirichlet_alpha() {
  dirichlet_alpha_ = 0;
}
inline float WorkerState_TreeOption::_internal_dirichlet_alpha() const {
  return dirichlet_alpha_;
}
inline float WorkerState_TreeOption::dirichlet_alpha() const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.TreeOption.dirichlet_alpha)
  return _internal_dirichlet_alpha();
}
inline void WorkerState_TreeOption::_internal_set_dirichlet_alpha(float value) {
  
  dirichlet_alpha_ = value;
}
inline void WorkerState_TreeOption::set_dirichlet_alpha(float value) {
  _internal_set_dirichlet_alpha(value);
  // @@protoc_insertion_point(field_set:clap.pb.WorkerState.TreeOption.dirichlet_alpha)
}

// float dirichlet_epsilon = 6;
inline void WorkerState_TreeOption::clear_dirichlet_epsilon() {
  dirichlet_epsilon_ = 0;
}
inline float WorkerState_TreeOption::_internal_dirichlet_epsilon() const {
  return dirichlet_epsilon_;
}
inline float WorkerState_TreeOption::dirichlet_epsilon() const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.TreeOption.dirichlet_epsilon)
  return _internal_dirichlet_epsilon();
}
inline void WorkerState_TreeOption::_internal_set_dirichlet_epsilon(float value) {
  
  dirichlet_epsilon_ = value;
}
inline void WorkerState_TreeOption::set_dirichlet_epsilon(float value) {
  _internal_set_dirichlet_epsilon(value);
  // @@protoc_insertion_point(field_set:clap.pb.WorkerState.TreeOption.dirichlet_epsilon)
}

// float discount = 7;
inline void WorkerState_TreeOption::clear_discount() {
  discount_ = 0;
}
inline float WorkerState_TreeOption::_internal_discount() const {
  return discount_;
}
inline float WorkerState_TreeOption::discount() const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.TreeOption.discount)
  return _internal_discount();
}
inline void WorkerState_TreeOption::_internal_set_discount(float value) {
  
  discount_ = value;
}
inline void WorkerState_TreeOption::set_discount(float value) {
  _internal_set_discount(value);
  // @@protoc_insertion_point(field_set:clap.pb.WorkerState.TreeOption.discount)
}

// -------------------------------------------------------------------

// WorkerState_Evaluation

// float value = 1;
inline void WorkerState_Evaluation::clear_value() {
  value_ = 0;
}
inline float WorkerState_Evaluation::_internal_value() const {
  return value_;
}
inline float WorkerState_Evaluation::value() const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.Evaluation.value)
  return _internal_value();
}
inline void WorkerState_Evaluation::_internal_set_value(float value) {
  
  value_ = value;
}
inline void WorkerState_Evaluation::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:clap.pb.WorkerState.Evaluation.value)
}

// repeated float policy = 2;
inline int WorkerState_Evaluation::_internal_policy_size() const {
  return policy_.size();
}
inline int WorkerState_Evaluation::policy_size() const {
  return _internal_policy_size();
}
inline void WorkerState_Evaluation::clear_policy() {
  policy_.Clear();
}
inline float WorkerState_Evaluation::_internal_policy(int index) const {
  return policy_.Get(index);
}
inline float WorkerState_Evaluation::policy(int index) const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.Evaluation.policy)
  return _internal_policy(index);
}
inline void WorkerState_Evaluation::set_policy(int index, float value) {
  policy_.Set(index, value);
  // @@protoc_insertion_point(field_set:clap.pb.WorkerState.Evaluation.policy)
}
inline void WorkerState_Evaluation::_internal_add_policy(float value) {
  policy_.Add(value);
}
inline void WorkerState_Evaluation::add_policy(float value) {
  _internal_add_policy(value);
  // @@protoc_insertion_point(field_add:clap.pb.WorkerState.Evaluation.policy)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
WorkerState_Evaluation::_internal_policy() const {
  return policy_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
WorkerState_Evaluation::policy() const {
  // @@protoc_insertion_point(field_list:clap.pb.WorkerState.Evaluation.policy)
  return _internal_policy();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
WorkerState_Evaluation::_internal_mutable_policy() {
  return &policy_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
WorkerState_Evaluation::mutable_policy() {
  // @@protoc_insertion_point(field_mutable_list:clap.pb.WorkerState.Evaluation.policy)
  return _internal_mutable_policy();
}

// float average_value = 3;
inline void WorkerState_Evaluation::clear_average_value() {
  average_value_ = 0;
}
inline float WorkerState_Evaluation::_internal_average_value() const {
  return average_value_;
}
inline float WorkerState_Evaluation::average_value() const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.Evaluation.average_value)
  return _internal_average_value();
}
inline void WorkerState_Evaluation::_internal_set_average_value(float value) {
  
  average_value_ = value;
}
inline void WorkerState_Evaluation::set_average_value(float value) {
  _internal_set_average_value(value);
  // @@protoc_insertion_point(field_set:clap.pb.WorkerState.Evaluation.average_value)
}

// -------------------------------------------------------------------

// WorkerState_Transition

// int32 current_player = 1;
inline void WorkerState_Transition::clear_current_player() {
  current_player_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WorkerState_Transition::_internal_current_player() const {
  return current_player_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WorkerState_Transition::current_player() const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.Transition.current_player)
  return _internal_current_player();
}
inline void WorkerState_Transition::_internal_set_current_player(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  current_player_ = value;
}
inline void WorkerState_Transition::set_current_player(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_current_player(value);
  // @@protoc_insertion_point(field_set:clap.pb.WorkerState.Transition.current_player)
}

// int32 action = 2;
inline void WorkerState_Transition::clear_action() {
  action_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WorkerState_Transition::_internal_action() const {
  return action_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WorkerState_Transition::action() const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.Transition.action)
  return _internal_action();
}
inline void WorkerState_Transition::_internal_set_action(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  action_ = value;
}
inline void WorkerState_Transition::set_action(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:clap.pb.WorkerState.Transition.action)
}

// repeated float rewards = 3;
inline int WorkerState_Transition::_internal_rewards_size() const {
  return rewards_.size();
}
inline int WorkerState_Transition::rewards_size() const {
  return _internal_rewards_size();
}
inline void WorkerState_Transition::clear_rewards() {
  rewards_.Clear();
}
inline float WorkerState_Transition::_internal_rewards(int index) const {
  return rewards_.Get(index);
}
inline float WorkerState_Transition::rewards(int index) const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.Transition.rewards)
  return _internal_rewards(index);
}
inline void WorkerState_Transition::set_rewards(int index, float value) {
  rewards_.Set(index, value);
  // @@protoc_insertion_point(field_set:clap.pb.WorkerState.Transition.rewards)
}
inline void WorkerState_Transition::_internal_add_rewards(float value) {
  rewards_.Add(value);
}
inline void WorkerState_Transition::add_rewards(float value) {
  _internal_add_rewards(value);
  // @@protoc_insertion_point(field_add:clap.pb.WorkerState.Transition.rewards)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
WorkerState_Transition::_internal_rewards() const {
  return rewards_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
WorkerState_Transition::rewards() const {
  // @@protoc_insertion_point(field_list:clap.pb.WorkerState.Transition.rewards)
  return _internal_rewards();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
WorkerState_Transition::_internal_mutable_rewards() {
  return &rewards_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
WorkerState_Transition::mutable_rewards() {
  // @@protoc_insertion_point(field_mutable_list:clap.pb.WorkerState.Transition.rewards)
  return _internal_mutable_rewards();
}

// -------------------------------------------------------------------

// WorkerState

// repeated int32 legal_actions = 1;
inline int WorkerState::_internal_legal_actions_size() const {
  return legal_actions_.size();
}
inline int WorkerState::legal_actions_size() const {
  return _internal_legal_actions_size();
}
inline void WorkerState::clear_legal_actions() {
  legal_actions_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WorkerState::_internal_legal_actions(int index) const {
  return legal_actions_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WorkerState::legal_actions(int index) const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.legal_actions)
  return _internal_legal_actions(index);
}
inline void WorkerState::set_legal_actions(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  legal_actions_.Set(index, value);
  // @@protoc_insertion_point(field_set:clap.pb.WorkerState.legal_actions)
}
inline void WorkerState::_internal_add_legal_actions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  legal_actions_.Add(value);
}
inline void WorkerState::add_legal_actions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_legal_actions(value);
  // @@protoc_insertion_point(field_add:clap.pb.WorkerState.legal_actions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
WorkerState::_internal_legal_actions() const {
  return legal_actions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
WorkerState::legal_actions() const {
  // @@protoc_insertion_point(field_list:clap.pb.WorkerState.legal_actions)
  return _internal_legal_actions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
WorkerState::_internal_mutable_legal_actions() {
  return &legal_actions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
WorkerState::mutable_legal_actions() {
  // @@protoc_insertion_point(field_mutable_list:clap.pb.WorkerState.legal_actions)
  return _internal_mutable_legal_actions();
}

// repeated float observation_tensor = 2;
inline int WorkerState::_internal_observation_tensor_size() const {
  return observation_tensor_.size();
}
inline int WorkerState::observation_tensor_size() const {
  return _internal_observation_tensor_size();
}
inline void WorkerState::clear_observation_tensor() {
  observation_tensor_.Clear();
}
inline float WorkerState::_internal_observation_tensor(int index) const {
  return observation_tensor_.Get(index);
}
inline float WorkerState::observation_tensor(int index) const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.observation_tensor)
  return _internal_observation_tensor(index);
}
inline void WorkerState::set_observation_tensor(int index, float value) {
  observation_tensor_.Set(index, value);
  // @@protoc_insertion_point(field_set:clap.pb.WorkerState.observation_tensor)
}
inline void WorkerState::_internal_add_observation_tensor(float value) {
  observation_tensor_.Add(value);
}
inline void WorkerState::add_observation_tensor(float value) {
  _internal_add_observation_tensor(value);
  // @@protoc_insertion_point(field_add:clap.pb.WorkerState.observation_tensor)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
WorkerState::_internal_observation_tensor() const {
  return observation_tensor_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
WorkerState::observation_tensor() const {
  // @@protoc_insertion_point(field_list:clap.pb.WorkerState.observation_tensor)
  return _internal_observation_tensor();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
WorkerState::_internal_mutable_observation_tensor() {
  return &observation_tensor_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
WorkerState::mutable_observation_tensor() {
  // @@protoc_insertion_point(field_mutable_list:clap.pb.WorkerState.observation_tensor)
  return _internal_mutable_observation_tensor();
}

// .clap.pb.WorkerState.TreeOption tree_option = 3;
inline bool WorkerState::_internal_has_tree_option() const {
  return this != internal_default_instance() && tree_option_ != nullptr;
}
inline bool WorkerState::has_tree_option() const {
  return _internal_has_tree_option();
}
inline void WorkerState::clear_tree_option() {
  if (GetArena() == nullptr && tree_option_ != nullptr) {
    delete tree_option_;
  }
  tree_option_ = nullptr;
}
inline const ::clap::pb::WorkerState_TreeOption& WorkerState::_internal_tree_option() const {
  const ::clap::pb::WorkerState_TreeOption* p = tree_option_;
  return p != nullptr ? *p : *reinterpret_cast<const ::clap::pb::WorkerState_TreeOption*>(
      &::clap::pb::_WorkerState_TreeOption_default_instance_);
}
inline const ::clap::pb::WorkerState_TreeOption& WorkerState::tree_option() const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.tree_option)
  return _internal_tree_option();
}
inline void WorkerState::unsafe_arena_set_allocated_tree_option(
    ::clap::pb::WorkerState_TreeOption* tree_option) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tree_option_);
  }
  tree_option_ = tree_option;
  if (tree_option) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clap.pb.WorkerState.tree_option)
}
inline ::clap::pb::WorkerState_TreeOption* WorkerState::release_tree_option() {
  
  ::clap::pb::WorkerState_TreeOption* temp = tree_option_;
  tree_option_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::clap::pb::WorkerState_TreeOption* WorkerState::unsafe_arena_release_tree_option() {
  // @@protoc_insertion_point(field_release:clap.pb.WorkerState.tree_option)
  
  ::clap::pb::WorkerState_TreeOption* temp = tree_option_;
  tree_option_ = nullptr;
  return temp;
}
inline ::clap::pb::WorkerState_TreeOption* WorkerState::_internal_mutable_tree_option() {
  
  if (tree_option_ == nullptr) {
    auto* p = CreateMaybeMessage<::clap::pb::WorkerState_TreeOption>(GetArena());
    tree_option_ = p;
  }
  return tree_option_;
}
inline ::clap::pb::WorkerState_TreeOption* WorkerState::mutable_tree_option() {
  // @@protoc_insertion_point(field_mutable:clap.pb.WorkerState.tree_option)
  return _internal_mutable_tree_option();
}
inline void WorkerState::set_allocated_tree_option(::clap::pb::WorkerState_TreeOption* tree_option) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tree_option_;
  }
  if (tree_option) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tree_option);
    if (message_arena != submessage_arena) {
      tree_option = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tree_option, submessage_arena);
    }
    
  } else {
    
  }
  tree_option_ = tree_option;
  // @@protoc_insertion_point(field_set_allocated:clap.pb.WorkerState.tree_option)
}

// .clap.pb.WorkerState.Evaluation evaluation = 4;
inline bool WorkerState::_internal_has_evaluation() const {
  return this != internal_default_instance() && evaluation_ != nullptr;
}
inline bool WorkerState::has_evaluation() const {
  return _internal_has_evaluation();
}
inline void WorkerState::clear_evaluation() {
  if (GetArena() == nullptr && evaluation_ != nullptr) {
    delete evaluation_;
  }
  evaluation_ = nullptr;
}
inline const ::clap::pb::WorkerState_Evaluation& WorkerState::_internal_evaluation() const {
  const ::clap::pb::WorkerState_Evaluation* p = evaluation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::clap::pb::WorkerState_Evaluation*>(
      &::clap::pb::_WorkerState_Evaluation_default_instance_);
}
inline const ::clap::pb::WorkerState_Evaluation& WorkerState::evaluation() const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.evaluation)
  return _internal_evaluation();
}
inline void WorkerState::unsafe_arena_set_allocated_evaluation(
    ::clap::pb::WorkerState_Evaluation* evaluation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(evaluation_);
  }
  evaluation_ = evaluation;
  if (evaluation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clap.pb.WorkerState.evaluation)
}
inline ::clap::pb::WorkerState_Evaluation* WorkerState::release_evaluation() {
  
  ::clap::pb::WorkerState_Evaluation* temp = evaluation_;
  evaluation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::clap::pb::WorkerState_Evaluation* WorkerState::unsafe_arena_release_evaluation() {
  // @@protoc_insertion_point(field_release:clap.pb.WorkerState.evaluation)
  
  ::clap::pb::WorkerState_Evaluation* temp = evaluation_;
  evaluation_ = nullptr;
  return temp;
}
inline ::clap::pb::WorkerState_Evaluation* WorkerState::_internal_mutable_evaluation() {
  
  if (evaluation_ == nullptr) {
    auto* p = CreateMaybeMessage<::clap::pb::WorkerState_Evaluation>(GetArena());
    evaluation_ = p;
  }
  return evaluation_;
}
inline ::clap::pb::WorkerState_Evaluation* WorkerState::mutable_evaluation() {
  // @@protoc_insertion_point(field_mutable:clap.pb.WorkerState.evaluation)
  return _internal_mutable_evaluation();
}
inline void WorkerState::set_allocated_evaluation(::clap::pb::WorkerState_Evaluation* evaluation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete evaluation_;
  }
  if (evaluation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(evaluation);
    if (message_arena != submessage_arena) {
      evaluation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, evaluation, submessage_arena);
    }
    
  } else {
    
  }
  evaluation_ = evaluation;
  // @@protoc_insertion_point(field_set_allocated:clap.pb.WorkerState.evaluation)
}

// .clap.pb.WorkerState.Transition transition = 5;
inline bool WorkerState::_internal_has_transition() const {
  return this != internal_default_instance() && transition_ != nullptr;
}
inline bool WorkerState::has_transition() const {
  return _internal_has_transition();
}
inline void WorkerState::clear_transition() {
  if (GetArena() == nullptr && transition_ != nullptr) {
    delete transition_;
  }
  transition_ = nullptr;
}
inline const ::clap::pb::WorkerState_Transition& WorkerState::_internal_transition() const {
  const ::clap::pb::WorkerState_Transition* p = transition_;
  return p != nullptr ? *p : *reinterpret_cast<const ::clap::pb::WorkerState_Transition*>(
      &::clap::pb::_WorkerState_Transition_default_instance_);
}
inline const ::clap::pb::WorkerState_Transition& WorkerState::transition() const {
  // @@protoc_insertion_point(field_get:clap.pb.WorkerState.transition)
  return _internal_transition();
}
inline void WorkerState::unsafe_arena_set_allocated_transition(
    ::clap::pb::WorkerState_Transition* transition) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transition_);
  }
  transition_ = transition;
  if (transition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clap.pb.WorkerState.transition)
}
inline ::clap::pb::WorkerState_Transition* WorkerState::release_transition() {
  
  ::clap::pb::WorkerState_Transition* temp = transition_;
  transition_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::clap::pb::WorkerState_Transition* WorkerState::unsafe_arena_release_transition() {
  // @@protoc_insertion_point(field_release:clap.pb.WorkerState.transition)
  
  ::clap::pb::WorkerState_Transition* temp = transition_;
  transition_ = nullptr;
  return temp;
}
inline ::clap::pb::WorkerState_Transition* WorkerState::_internal_mutable_transition() {
  
  if (transition_ == nullptr) {
    auto* p = CreateMaybeMessage<::clap::pb::WorkerState_Transition>(GetArena());
    transition_ = p;
  }
  return transition_;
}
inline ::clap::pb::WorkerState_Transition* WorkerState::mutable_transition() {
  // @@protoc_insertion_point(field_mutable:clap.pb.WorkerState.transition)
  return _internal_mutable_transition();
}
inline void WorkerState::set_allocated_transition(::clap::pb::WorkerState_Transition* transition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete transition_;
  }
  if (transition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(transition);
    if (message_arena != submessage_arena) {
      transition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transition, submessage_arena);
    }
    
  } else {
    
  }
  transition_ = transition;
  // @@protoc_insertion_point(field_set_allocated:clap.pb.WorkerState.transition)
}

// -------------------------------------------------------------------

// Trajectory_Statistics

// repeated float rewards = 1;
inline int Trajectory_Statistics::_internal_rewards_size() const {
  return rewards_.size();
}
inline int Trajectory_Statistics::rewards_size() const {
  return _internal_rewards_size();
}
inline void Trajectory_Statistics::clear_rewards() {
  rewards_.Clear();
}
inline float Trajectory_Statistics::_internal_rewards(int index) const {
  return rewards_.Get(index);
}
inline float Trajectory_Statistics::rewards(int index) const {
  // @@protoc_insertion_point(field_get:clap.pb.Trajectory.Statistics.rewards)
  return _internal_rewards(index);
}
inline void Trajectory_Statistics::set_rewards(int index, float value) {
  rewards_.Set(index, value);
  // @@protoc_insertion_point(field_set:clap.pb.Trajectory.Statistics.rewards)
}
inline void Trajectory_Statistics::_internal_add_rewards(float value) {
  rewards_.Add(value);
}
inline void Trajectory_Statistics::add_rewards(float value) {
  _internal_add_rewards(value);
  // @@protoc_insertion_point(field_add:clap.pb.Trajectory.Statistics.rewards)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Trajectory_Statistics::_internal_rewards() const {
  return rewards_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Trajectory_Statistics::rewards() const {
  // @@protoc_insertion_point(field_list:clap.pb.Trajectory.Statistics.rewards)
  return _internal_rewards();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Trajectory_Statistics::_internal_mutable_rewards() {
  return &rewards_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Trajectory_Statistics::mutable_rewards() {
  // @@protoc_insertion_point(field_mutable_list:clap.pb.Trajectory.Statistics.rewards)
  return _internal_mutable_rewards();
}

// int32 game_steps = 2;
inline void Trajectory_Statistics::clear_game_steps() {
  game_steps_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Trajectory_Statistics::_internal_game_steps() const {
  return game_steps_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Trajectory_Statistics::game_steps() const {
  // @@protoc_insertion_point(field_get:clap.pb.Trajectory.Statistics.game_steps)
  return _internal_game_steps();
}
inline void Trajectory_Statistics::_internal_set_game_steps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  game_steps_ = value;
}
inline void Trajectory_Statistics::set_game_steps(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_game_steps(value);
  // @@protoc_insertion_point(field_set:clap.pb.Trajectory.Statistics.game_steps)
}

// -------------------------------------------------------------------

// Trajectory

// repeated .clap.pb.WorkerState states = 1;
inline int Trajectory::_internal_states_size() const {
  return states_.size();
}
inline int Trajectory::states_size() const {
  return _internal_states_size();
}
inline void Trajectory::clear_states() {
  states_.Clear();
}
inline ::clap::pb::WorkerState* Trajectory::mutable_states(int index) {
  // @@protoc_insertion_point(field_mutable:clap.pb.Trajectory.states)
  return states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::WorkerState >*
Trajectory::mutable_states() {
  // @@protoc_insertion_point(field_mutable_list:clap.pb.Trajectory.states)
  return &states_;
}
inline const ::clap::pb::WorkerState& Trajectory::_internal_states(int index) const {
  return states_.Get(index);
}
inline const ::clap::pb::WorkerState& Trajectory::states(int index) const {
  // @@protoc_insertion_point(field_get:clap.pb.Trajectory.states)
  return _internal_states(index);
}
inline ::clap::pb::WorkerState* Trajectory::_internal_add_states() {
  return states_.Add();
}
inline ::clap::pb::WorkerState* Trajectory::add_states() {
  // @@protoc_insertion_point(field_add:clap.pb.Trajectory.states)
  return _internal_add_states();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::WorkerState >&
Trajectory::states() const {
  // @@protoc_insertion_point(field_list:clap.pb.Trajectory.states)
  return states_;
}

// .clap.pb.Trajectory.Statistics statistics = 2;
inline bool Trajectory::_internal_has_statistics() const {
  return this != internal_default_instance() && statistics_ != nullptr;
}
inline bool Trajectory::has_statistics() const {
  return _internal_has_statistics();
}
inline void Trajectory::clear_statistics() {
  if (GetArena() == nullptr && statistics_ != nullptr) {
    delete statistics_;
  }
  statistics_ = nullptr;
}
inline const ::clap::pb::Trajectory_Statistics& Trajectory::_internal_statistics() const {
  const ::clap::pb::Trajectory_Statistics* p = statistics_;
  return p != nullptr ? *p : *reinterpret_cast<const ::clap::pb::Trajectory_Statistics*>(
      &::clap::pb::_Trajectory_Statistics_default_instance_);
}
inline const ::clap::pb::Trajectory_Statistics& Trajectory::statistics() const {
  // @@protoc_insertion_point(field_get:clap.pb.Trajectory.statistics)
  return _internal_statistics();
}
inline void Trajectory::unsafe_arena_set_allocated_statistics(
    ::clap::pb::Trajectory_Statistics* statistics) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statistics_);
  }
  statistics_ = statistics;
  if (statistics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clap.pb.Trajectory.statistics)
}
inline ::clap::pb::Trajectory_Statistics* Trajectory::release_statistics() {
  
  ::clap::pb::Trajectory_Statistics* temp = statistics_;
  statistics_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::clap::pb::Trajectory_Statistics* Trajectory::unsafe_arena_release_statistics() {
  // @@protoc_insertion_point(field_release:clap.pb.Trajectory.statistics)
  
  ::clap::pb::Trajectory_Statistics* temp = statistics_;
  statistics_ = nullptr;
  return temp;
}
inline ::clap::pb::Trajectory_Statistics* Trajectory::_internal_mutable_statistics() {
  
  if (statistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::clap::pb::Trajectory_Statistics>(GetArena());
    statistics_ = p;
  }
  return statistics_;
}
inline ::clap::pb::Trajectory_Statistics* Trajectory::mutable_statistics() {
  // @@protoc_insertion_point(field_mutable:clap.pb.Trajectory.statistics)
  return _internal_mutable_statistics();
}
inline void Trajectory::set_allocated_statistics(::clap::pb::Trajectory_Statistics* statistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete statistics_;
  }
  if (statistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(statistics);
    if (message_arena != submessage_arena) {
      statistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statistics, submessage_arena);
    }
    
  } else {
    
  }
  statistics_ = statistics;
  // @@protoc_insertion_point(field_set_allocated:clap.pb.Trajectory.statistics)
}

// string appendix = 3;
inline void Trajectory::clear_appendix() {
  appendix_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Trajectory::appendix() const {
  // @@protoc_insertion_point(field_get:clap.pb.Trajectory.appendix)
  return _internal_appendix();
}
inline void Trajectory::set_appendix(const std::string& value) {
  _internal_set_appendix(value);
  // @@protoc_insertion_point(field_set:clap.pb.Trajectory.appendix)
}
inline std::string* Trajectory::mutable_appendix() {
  // @@protoc_insertion_point(field_mutable:clap.pb.Trajectory.appendix)
  return _internal_mutable_appendix();
}
inline const std::string& Trajectory::_internal_appendix() const {
  return appendix_.Get();
}
inline void Trajectory::_internal_set_appendix(const std::string& value) {
  
  appendix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Trajectory::set_appendix(std::string&& value) {
  
  appendix_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:clap.pb.Trajectory.appendix)
}
inline void Trajectory::set_appendix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  appendix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:clap.pb.Trajectory.appendix)
}
inline void Trajectory::set_appendix(const char* value,
    size_t size) {
  
  appendix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:clap.pb.Trajectory.appendix)
}
inline std::string* Trajectory::_internal_mutable_appendix() {
  
  return appendix_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Trajectory::release_appendix() {
  // @@protoc_insertion_point(field_release:clap.pb.Trajectory.appendix)
  return appendix_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Trajectory::set_allocated_appendix(std::string* appendix) {
  if (appendix != nullptr) {
    
  } else {
    
  }
  appendix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), appendix,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:clap.pb.Trajectory.appendix)
}

// -------------------------------------------------------------------

// Trajectories

// repeated .clap.pb.Trajectory trajectories = 1;
inline int Trajectories::_internal_trajectories_size() const {
  return trajectories_.size();
}
inline int Trajectories::trajectories_size() const {
  return _internal_trajectories_size();
}
inline void Trajectories::clear_trajectories() {
  trajectories_.Clear();
}
inline ::clap::pb::Trajectory* Trajectories::mutable_trajectories(int index) {
  // @@protoc_insertion_point(field_mutable:clap.pb.Trajectories.trajectories)
  return trajectories_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::Trajectory >*
Trajectories::mutable_trajectories() {
  // @@protoc_insertion_point(field_mutable_list:clap.pb.Trajectories.trajectories)
  return &trajectories_;
}
inline const ::clap::pb::Trajectory& Trajectories::_internal_trajectories(int index) const {
  return trajectories_.Get(index);
}
inline const ::clap::pb::Trajectory& Trajectories::trajectories(int index) const {
  // @@protoc_insertion_point(field_get:clap.pb.Trajectories.trajectories)
  return _internal_trajectories(index);
}
inline ::clap::pb::Trajectory* Trajectories::_internal_add_trajectories() {
  return trajectories_.Add();
}
inline ::clap::pb::Trajectory* Trajectories::add_trajectories() {
  // @@protoc_insertion_point(field_add:clap.pb.Trajectories.trajectories)
  return _internal_add_trajectories();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::clap::pb::Trajectory >&
Trajectories::trajectories() const {
  // @@protoc_insertion_point(field_list:clap.pb.Trajectories.trajectories)
  return trajectories_;
}

// -------------------------------------------------------------------

// Heartbeat

// -------------------------------------------------------------------

// Packet

// .clap.pb.Heartbeat heartbeat = 1;
inline bool Packet::_internal_has_heartbeat() const {
  return payload_case() == kHeartbeat;
}
inline bool Packet::has_heartbeat() const {
  return _internal_has_heartbeat();
}
inline void Packet::set_has_heartbeat() {
  _oneof_case_[0] = kHeartbeat;
}
inline void Packet::clear_heartbeat() {
  if (_internal_has_heartbeat()) {
    if (GetArena() == nullptr) {
      delete payload_.heartbeat_;
    }
    clear_has_payload();
  }
}
inline ::clap::pb::Heartbeat* Packet::release_heartbeat() {
  // @@protoc_insertion_point(field_release:clap.pb.Packet.heartbeat)
  if (_internal_has_heartbeat()) {
    clear_has_payload();
      ::clap::pb::Heartbeat* temp = payload_.heartbeat_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clap::pb::Heartbeat& Packet::_internal_heartbeat() const {
  return _internal_has_heartbeat()
      ? *payload_.heartbeat_
      : *reinterpret_cast< ::clap::pb::Heartbeat*>(&::clap::pb::_Heartbeat_default_instance_);
}
inline const ::clap::pb::Heartbeat& Packet::heartbeat() const {
  // @@protoc_insertion_point(field_get:clap.pb.Packet.heartbeat)
  return _internal_heartbeat();
}
inline ::clap::pb::Heartbeat* Packet::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clap.pb.Packet.heartbeat)
  if (_internal_has_heartbeat()) {
    clear_has_payload();
    ::clap::pb::Heartbeat* temp = payload_.heartbeat_;
    payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_heartbeat(::clap::pb::Heartbeat* heartbeat) {
  clear_payload();
  if (heartbeat) {
    set_has_heartbeat();
    payload_.heartbeat_ = heartbeat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clap.pb.Packet.heartbeat)
}
inline ::clap::pb::Heartbeat* Packet::_internal_mutable_heartbeat() {
  if (!_internal_has_heartbeat()) {
    clear_payload();
    set_has_heartbeat();
    payload_.heartbeat_ = CreateMaybeMessage< ::clap::pb::Heartbeat >(GetArena());
  }
  return payload_.heartbeat_;
}
inline ::clap::pb::Heartbeat* Packet::mutable_heartbeat() {
  // @@protoc_insertion_point(field_mutable:clap.pb.Packet.heartbeat)
  return _internal_mutable_heartbeat();
}

// .clap.pb.Heartbeat goodbye = 2;
inline bool Packet::_internal_has_goodbye() const {
  return payload_case() == kGoodbye;
}
inline bool Packet::has_goodbye() const {
  return _internal_has_goodbye();
}
inline void Packet::set_has_goodbye() {
  _oneof_case_[0] = kGoodbye;
}
inline void Packet::clear_goodbye() {
  if (_internal_has_goodbye()) {
    if (GetArena() == nullptr) {
      delete payload_.goodbye_;
    }
    clear_has_payload();
  }
}
inline ::clap::pb::Heartbeat* Packet::release_goodbye() {
  // @@protoc_insertion_point(field_release:clap.pb.Packet.goodbye)
  if (_internal_has_goodbye()) {
    clear_has_payload();
      ::clap::pb::Heartbeat* temp = payload_.goodbye_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.goodbye_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clap::pb::Heartbeat& Packet::_internal_goodbye() const {
  return _internal_has_goodbye()
      ? *payload_.goodbye_
      : *reinterpret_cast< ::clap::pb::Heartbeat*>(&::clap::pb::_Heartbeat_default_instance_);
}
inline const ::clap::pb::Heartbeat& Packet::goodbye() const {
  // @@protoc_insertion_point(field_get:clap.pb.Packet.goodbye)
  return _internal_goodbye();
}
inline ::clap::pb::Heartbeat* Packet::unsafe_arena_release_goodbye() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clap.pb.Packet.goodbye)
  if (_internal_has_goodbye()) {
    clear_has_payload();
    ::clap::pb::Heartbeat* temp = payload_.goodbye_;
    payload_.goodbye_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_goodbye(::clap::pb::Heartbeat* goodbye) {
  clear_payload();
  if (goodbye) {
    set_has_goodbye();
    payload_.goodbye_ = goodbye;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clap.pb.Packet.goodbye)
}
inline ::clap::pb::Heartbeat* Packet::_internal_mutable_goodbye() {
  if (!_internal_has_goodbye()) {
    clear_payload();
    set_has_goodbye();
    payload_.goodbye_ = CreateMaybeMessage< ::clap::pb::Heartbeat >(GetArena());
  }
  return payload_.goodbye_;
}
inline ::clap::pb::Heartbeat* Packet::mutable_goodbye() {
  // @@protoc_insertion_point(field_mutable:clap.pb.Packet.goodbye)
  return _internal_mutable_goodbye();
}

// .clap.pb.Heartbeat model_subscribe = 3;
inline bool Packet::_internal_has_model_subscribe() const {
  return payload_case() == kModelSubscribe;
}
inline bool Packet::has_model_subscribe() const {
  return _internal_has_model_subscribe();
}
inline void Packet::set_has_model_subscribe() {
  _oneof_case_[0] = kModelSubscribe;
}
inline void Packet::clear_model_subscribe() {
  if (_internal_has_model_subscribe()) {
    if (GetArena() == nullptr) {
      delete payload_.model_subscribe_;
    }
    clear_has_payload();
  }
}
inline ::clap::pb::Heartbeat* Packet::release_model_subscribe() {
  // @@protoc_insertion_point(field_release:clap.pb.Packet.model_subscribe)
  if (_internal_has_model_subscribe()) {
    clear_has_payload();
      ::clap::pb::Heartbeat* temp = payload_.model_subscribe_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.model_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clap::pb::Heartbeat& Packet::_internal_model_subscribe() const {
  return _internal_has_model_subscribe()
      ? *payload_.model_subscribe_
      : *reinterpret_cast< ::clap::pb::Heartbeat*>(&::clap::pb::_Heartbeat_default_instance_);
}
inline const ::clap::pb::Heartbeat& Packet::model_subscribe() const {
  // @@protoc_insertion_point(field_get:clap.pb.Packet.model_subscribe)
  return _internal_model_subscribe();
}
inline ::clap::pb::Heartbeat* Packet::unsafe_arena_release_model_subscribe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clap.pb.Packet.model_subscribe)
  if (_internal_has_model_subscribe()) {
    clear_has_payload();
    ::clap::pb::Heartbeat* temp = payload_.model_subscribe_;
    payload_.model_subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_model_subscribe(::clap::pb::Heartbeat* model_subscribe) {
  clear_payload();
  if (model_subscribe) {
    set_has_model_subscribe();
    payload_.model_subscribe_ = model_subscribe;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clap.pb.Packet.model_subscribe)
}
inline ::clap::pb::Heartbeat* Packet::_internal_mutable_model_subscribe() {
  if (!_internal_has_model_subscribe()) {
    clear_payload();
    set_has_model_subscribe();
    payload_.model_subscribe_ = CreateMaybeMessage< ::clap::pb::Heartbeat >(GetArena());
  }
  return payload_.model_subscribe_;
}
inline ::clap::pb::Heartbeat* Packet::mutable_model_subscribe() {
  // @@protoc_insertion_point(field_mutable:clap.pb.Packet.model_subscribe)
  return _internal_mutable_model_subscribe();
}

// .clap.pb.ModelInfo model_info = 4;
inline bool Packet::_internal_has_model_info() const {
  return payload_case() == kModelInfo;
}
inline bool Packet::has_model_info() const {
  return _internal_has_model_info();
}
inline void Packet::set_has_model_info() {
  _oneof_case_[0] = kModelInfo;
}
inline void Packet::clear_model_info() {
  if (_internal_has_model_info()) {
    if (GetArena() == nullptr) {
      delete payload_.model_info_;
    }
    clear_has_payload();
  }
}
inline ::clap::pb::ModelInfo* Packet::release_model_info() {
  // @@protoc_insertion_point(field_release:clap.pb.Packet.model_info)
  if (_internal_has_model_info()) {
    clear_has_payload();
      ::clap::pb::ModelInfo* temp = payload_.model_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.model_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clap::pb::ModelInfo& Packet::_internal_model_info() const {
  return _internal_has_model_info()
      ? *payload_.model_info_
      : *reinterpret_cast< ::clap::pb::ModelInfo*>(&::clap::pb::_ModelInfo_default_instance_);
}
inline const ::clap::pb::ModelInfo& Packet::model_info() const {
  // @@protoc_insertion_point(field_get:clap.pb.Packet.model_info)
  return _internal_model_info();
}
inline ::clap::pb::ModelInfo* Packet::unsafe_arena_release_model_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clap.pb.Packet.model_info)
  if (_internal_has_model_info()) {
    clear_has_payload();
    ::clap::pb::ModelInfo* temp = payload_.model_info_;
    payload_.model_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_model_info(::clap::pb::ModelInfo* model_info) {
  clear_payload();
  if (model_info) {
    set_has_model_info();
    payload_.model_info_ = model_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clap.pb.Packet.model_info)
}
inline ::clap::pb::ModelInfo* Packet::_internal_mutable_model_info() {
  if (!_internal_has_model_info()) {
    clear_payload();
    set_has_model_info();
    payload_.model_info_ = CreateMaybeMessage< ::clap::pb::ModelInfo >(GetArena());
  }
  return payload_.model_info_;
}
inline ::clap::pb::ModelInfo* Packet::mutable_model_info() {
  // @@protoc_insertion_point(field_mutable:clap.pb.Packet.model_info)
  return _internal_mutable_model_info();
}

// .clap.pb.ModelInfo model_request = 5;
inline bool Packet::_internal_has_model_request() const {
  return payload_case() == kModelRequest;
}
inline bool Packet::has_model_request() const {
  return _internal_has_model_request();
}
inline void Packet::set_has_model_request() {
  _oneof_case_[0] = kModelRequest;
}
inline void Packet::clear_model_request() {
  if (_internal_has_model_request()) {
    if (GetArena() == nullptr) {
      delete payload_.model_request_;
    }
    clear_has_payload();
  }
}
inline ::clap::pb::ModelInfo* Packet::release_model_request() {
  // @@protoc_insertion_point(field_release:clap.pb.Packet.model_request)
  if (_internal_has_model_request()) {
    clear_has_payload();
      ::clap::pb::ModelInfo* temp = payload_.model_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.model_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clap::pb::ModelInfo& Packet::_internal_model_request() const {
  return _internal_has_model_request()
      ? *payload_.model_request_
      : *reinterpret_cast< ::clap::pb::ModelInfo*>(&::clap::pb::_ModelInfo_default_instance_);
}
inline const ::clap::pb::ModelInfo& Packet::model_request() const {
  // @@protoc_insertion_point(field_get:clap.pb.Packet.model_request)
  return _internal_model_request();
}
inline ::clap::pb::ModelInfo* Packet::unsafe_arena_release_model_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clap.pb.Packet.model_request)
  if (_internal_has_model_request()) {
    clear_has_payload();
    ::clap::pb::ModelInfo* temp = payload_.model_request_;
    payload_.model_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_model_request(::clap::pb::ModelInfo* model_request) {
  clear_payload();
  if (model_request) {
    set_has_model_request();
    payload_.model_request_ = model_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clap.pb.Packet.model_request)
}
inline ::clap::pb::ModelInfo* Packet::_internal_mutable_model_request() {
  if (!_internal_has_model_request()) {
    clear_payload();
    set_has_model_request();
    payload_.model_request_ = CreateMaybeMessage< ::clap::pb::ModelInfo >(GetArena());
  }
  return payload_.model_request_;
}
inline ::clap::pb::ModelInfo* Packet::mutable_model_request() {
  // @@protoc_insertion_point(field_mutable:clap.pb.Packet.model_request)
  return _internal_mutable_model_request();
}

// .clap.pb.Model model_response = 6;
inline bool Packet::_internal_has_model_response() const {
  return payload_case() == kModelResponse;
}
inline bool Packet::has_model_response() const {
  return _internal_has_model_response();
}
inline void Packet::set_has_model_response() {
  _oneof_case_[0] = kModelResponse;
}
inline void Packet::clear_model_response() {
  if (_internal_has_model_response()) {
    if (GetArena() == nullptr) {
      delete payload_.model_response_;
    }
    clear_has_payload();
  }
}
inline ::clap::pb::Model* Packet::release_model_response() {
  // @@protoc_insertion_point(field_release:clap.pb.Packet.model_response)
  if (_internal_has_model_response()) {
    clear_has_payload();
      ::clap::pb::Model* temp = payload_.model_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.model_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clap::pb::Model& Packet::_internal_model_response() const {
  return _internal_has_model_response()
      ? *payload_.model_response_
      : *reinterpret_cast< ::clap::pb::Model*>(&::clap::pb::_Model_default_instance_);
}
inline const ::clap::pb::Model& Packet::model_response() const {
  // @@protoc_insertion_point(field_get:clap.pb.Packet.model_response)
  return _internal_model_response();
}
inline ::clap::pb::Model* Packet::unsafe_arena_release_model_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clap.pb.Packet.model_response)
  if (_internal_has_model_response()) {
    clear_has_payload();
    ::clap::pb::Model* temp = payload_.model_response_;
    payload_.model_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_model_response(::clap::pb::Model* model_response) {
  clear_payload();
  if (model_response) {
    set_has_model_response();
    payload_.model_response_ = model_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clap.pb.Packet.model_response)
}
inline ::clap::pb::Model* Packet::_internal_mutable_model_response() {
  if (!_internal_has_model_response()) {
    clear_payload();
    set_has_model_response();
    payload_.model_response_ = CreateMaybeMessage< ::clap::pb::Model >(GetArena());
  }
  return payload_.model_response_;
}
inline ::clap::pb::Model* Packet::mutable_model_response() {
  // @@protoc_insertion_point(field_mutable:clap.pb.Packet.model_response)
  return _internal_mutable_model_response();
}

// .clap.pb.Trajectory trajectory = 7;
inline bool Packet::_internal_has_trajectory() const {
  return payload_case() == kTrajectory;
}
inline bool Packet::has_trajectory() const {
  return _internal_has_trajectory();
}
inline void Packet::set_has_trajectory() {
  _oneof_case_[0] = kTrajectory;
}
inline void Packet::clear_trajectory() {
  if (_internal_has_trajectory()) {
    if (GetArena() == nullptr) {
      delete payload_.trajectory_;
    }
    clear_has_payload();
  }
}
inline ::clap::pb::Trajectory* Packet::release_trajectory() {
  // @@protoc_insertion_point(field_release:clap.pb.Packet.trajectory)
  if (_internal_has_trajectory()) {
    clear_has_payload();
      ::clap::pb::Trajectory* temp = payload_.trajectory_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.trajectory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::clap::pb::Trajectory& Packet::_internal_trajectory() const {
  return _internal_has_trajectory()
      ? *payload_.trajectory_
      : *reinterpret_cast< ::clap::pb::Trajectory*>(&::clap::pb::_Trajectory_default_instance_);
}
inline const ::clap::pb::Trajectory& Packet::trajectory() const {
  // @@protoc_insertion_point(field_get:clap.pb.Packet.trajectory)
  return _internal_trajectory();
}
inline ::clap::pb::Trajectory* Packet::unsafe_arena_release_trajectory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:clap.pb.Packet.trajectory)
  if (_internal_has_trajectory()) {
    clear_has_payload();
    ::clap::pb::Trajectory* temp = payload_.trajectory_;
    payload_.trajectory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_trajectory(::clap::pb::Trajectory* trajectory) {
  clear_payload();
  if (trajectory) {
    set_has_trajectory();
    payload_.trajectory_ = trajectory;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:clap.pb.Packet.trajectory)
}
inline ::clap::pb::Trajectory* Packet::_internal_mutable_trajectory() {
  if (!_internal_has_trajectory()) {
    clear_payload();
    set_has_trajectory();
    payload_.trajectory_ = CreateMaybeMessage< ::clap::pb::Trajectory >(GetArena());
  }
  return payload_.trajectory_;
}
inline ::clap::pb::Trajectory* Packet::mutable_trajectory() {
  // @@protoc_insertion_point(field_mutable:clap.pb.Packet.trajectory)
  return _internal_mutable_trajectory();
}

inline bool Packet::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Packet::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Packet::PayloadCase Packet::payload_case() const {
  return Packet::PayloadCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace clap

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_clap_2eproto
